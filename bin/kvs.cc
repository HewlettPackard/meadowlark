/*
 *  (c) Copyright 2016-2017, 2021 Hewlett Packard Enterprise Development Company LP.
 *
 *  This software is available to you under a choice of one of two
 *  licenses. You may choose to be licensed under the terms of the
 *  GNU Lesser General Public License Version 3, or (at your option)
 *  later with exceptions included below, or under the terms of the
 *  MIT license (Expat) available in COPYING file in the source tree.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <sstream>
#include <cstdlib> // system()
#include <fstream>

#include "nvmm/epoch_manager.h"
#include "nvmm/memory_manager.h"
#include "nvmm/heap.h"

#include "radixtree/kvs.h"
#include "radixtree/radix_tree.h"

#include "cluster/config.h"
#include "cluster/cluster.h"

#include "kvs_client/kvs_client.h"


using namespace radixtree;
using namespace nvmm;

void start(std::string base="", std::string user="") {
    KeyValueStore::Start(base, user);
}

void reset(std::string base="", std::string user="") {
    KeyValueStore::Reset(base, user);
}

void restart(std::string base="", std::string user="") {
    KeyValueStore::Restart(base, user);
}

int createKVS(std::string type_str, size_t size, GlobalPtr &root, std::string base="", std::string user="") {
    if(type_str.find("tiny")!=std::string::npos) {
        std::cout << "Invalid KVS type: type_str" << std::endl;
        std::cout << "Only radixtree and hashtable are supported" << std::endl;
        return -1;
    }
        

    // reset(base, user);
    start(base, user);

    KeyValueStore *kvs = KeyValueStore::MakeKVS(type_str, 0, base, user, size);
    if(kvs==nullptr) {
        std::cout << "KVS creation failed" << std::endl;
        return -1;
    }
    else {
        root=kvs->Location();
        std::cout << "KVS created at: " << root << std::endl;
        delete kvs;
        return 0;
    }
}

inline void ResetBuf(char *buf, size_t &len, size_t const max_len) {
    memset(buf, 0, max_len);
    len=max_len;
}

GlobalPtr str2gptr(std::string root_str) {
    std::string delimiter = ":";
    size_t loc = root_str.find(delimiter);
    if (loc==std::string::npos)
        return 0;
    std::string shelf_id = root_str.substr(1, loc-1);
    std::string offset = root_str.substr(loc+1, root_str.size()-3-shelf_id.size());
    return GlobalPtr((unsigned char)std::stoul(shelf_id), std::stoul(offset));
}

int scanKVS(std::string type_str, GlobalPtr root, std::string base="", std::string user="") {
    if(type_str!="radixtree") {
        std::cout << "Only radixtree supports scan" << std::endl;
        return -1;
    }

    start(base, user);

    KeyValueStore *kvs;

    kvs = KeyValueStore::MakeKVS(KeyValueStore::RADIX_TREE, root, base, user);
    if(kvs==nullptr) {
        std::cout << "Failed to open the radixtree at " << root << std::endl;
        return -1;
    }

    size_t const max_val_len = 4096;
    size_t const max_key_len = kvs->MaxKeyLen();

    std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
    std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);

    char key_buf[max_key_len];
    size_t key_len;
    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(key_buf, key_len, max_key_len);
    ResetBuf(val_buf, val_len, max_val_len);

    int iter;
    int ret = kvs->Scan(iter,
                        key_buf, key_len,
                        val_buf, val_len,
                        begin_key.c_str(), begin_key.size(), false,
                        end_key.c_str(), end_key.size(), false);

    if(ret!=0) {
        std::cout << "KVS scan failed... KVS is empty? " << std::endl;
    }
    while(ret==0) {
        std::cout << std::string(key_buf, key_len) << " -> " << std::string(val_buf, val_len) << std::endl;
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
    }

    delete kvs;
    return 0;
}

int putKVS(std::string type_str, GlobalPtr root, std::string key, std::string val, std::string base="", std::string user="") {
    KeyValueStore::IndexType type;
    if(type_str=="radixtree") {
        type = KeyValueStore::RADIX_TREE;
    }
    else {
        type = KeyValueStore::HASH_TABLE;
    }

    KeyValueStore *kvs;

    kvs = KeyValueStore::MakeKVS(type, root, base, user);
    if(kvs==nullptr) {
        std::cout << "Failed to open the KVS at " << root << std::endl;
        return -1;
    }

    int ret = kvs->Put( key.c_str(), key.size(),
                        val.c_str(), val.size());
    if(ret!=0) {
        std::cout << "KVS Put failed" << std::endl;
        std::cout << "  key is: " << key << std::endl;
    }
    else {
        std::cout << "KVS Put succeeded: " << std::endl;
        std::cout << "  key is: " << key << std::endl;
        std::cout << "  val is: " << val << std::endl;
    }

    delete kvs;
    return 0;
}

int getKVS(std::string type_str, GlobalPtr root, std::string key, std::string base="", std::string user="") {
    KeyValueStore::IndexType type;
    if(type_str=="radixtree") {
        type = KeyValueStore::RADIX_TREE;
    }
    else {
        type = KeyValueStore::HASH_TABLE;
    }

    KeyValueStore *kvs;

    kvs = KeyValueStore::MakeKVS(type, root, base, user);
    if(kvs==nullptr) {
        std::cout << "Failed to open the KVS at " << root << std::endl;
        return -1;
    }

    size_t const max_val_len = 4096;

    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(val_buf, val_len, max_val_len);

    int ret = kvs->Get( key.c_str(), key.size(),
                        val_buf, val_len );

    if(ret!=0) {
        std::cout << "KVS Get failed" << std::endl;
        std::cout << "  key is: " << key << std::endl;
        if(val_len>max_val_len) std::cout << " require val buffer of size " << val_len << std::endl;
    }
    else {
        std::cout << "KVS Get succeeded: " << std::endl;
        std::cout << "  key is: " << key << std::endl;
        std::cout << "  val is (val_len " << val_len << "): " << std::string(val_buf, val_len) << std::endl;
    }

    delete kvs;
    return 0;
}

int delKVS(std::string type_str, GlobalPtr root, std::string key, std::string base="", std::string user="") {
    KeyValueStore::IndexType type;
    if(type_str=="radixtree") {
        type = KeyValueStore::RADIX_TREE;
    }
    else {
        type = KeyValueStore::HASH_TABLE;
    }

    KeyValueStore *kvs;

    kvs = KeyValueStore::MakeKVS(type, root, base, user);
    if(kvs==nullptr) {
        std::cout << "Failed to open the KVS at " << root << std::endl;
        return -1;
    }

    int ret = kvs->Del( key.c_str(), key.size() );
    if(ret!=0) {
        std::cout << "KVS Del failed" << std::endl;
        std::cout << "  key is: " << key << std::endl;
    }
    else {
        std::cout << "KVS Del succeeded: " << std::endl;
        std::cout << "  key is: " << key << std::endl;
    }

    delete kvs;
    return 0;
}

int printKVS(std::string type_str, GlobalPtr root, std::string base="", std::string user="") {
    if(type_str.find("radixtree")==std::string::npos) {
        std::cout << "Only radixtree supports print" << std::endl;
        return -1;
    }
    start(base, user);
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = mm->FindHeap(KeyValueStore::default_heap_id_);
    assert(heap);

    RadixTree *tree = new RadixTree(mm, heap, NULL, root);
    tree->list([&mm](const char *key, const int key_size, GlobalPtr p) {
            //char *value = (char*)mm->GlobalToLocal(p);
            //std::cout <<"  " << std::string(key, key_size)  << " -> " << p << std::endl;
             });
    delete tree;
    return 0;
}

void start_servers(std::string config_path, std::string server_path, std::string prefix="") {
    std::cout << "Starting memcached servers..." << std::endl;
    Config conf;
    conf.LoadConfigFile(config_path);

    uint64_t partition_per_node=1;
    if(conf.GetReplicationScheme() == Config::ReplicationScheme::DYNAMO)
        partition_per_node=conf.GetReplicationFactor();

    for(uint64_t i=0; i<conf.GetNodeCnt(); i++) {
        for(uint64_t j=0; j<partition_per_node; j++) {
            // TODO: -d would run fork() which does not work with nvmm
            std::string cmd = server_path+" -K "+config_path+" -N "+std::to_string(i)+" -Z "+std::to_string(j) + " &";
            if(!prefix.empty()) {
                // prefix could be:
                // LD_PRELOAD=/home/volos/workspace/quartz/build-smaug-3/src/lib/libnvmemul.so NVMEMUL_GENERAL_NODEBIND=
                // or
                // numactl --cpunodebind=
                cmd=prefix + std::to_string(i) + " " + cmd;
            }
            std::cout << "Executing: " << cmd << std::endl;
            system(cmd.c_str());
            std::cout << "Done: " << cmd << std::endl;
        }
    }
}

void stop_servers() {
    std::cout << "Stopping memcached servers..." << std::endl;
    system("pkill memcached");
    system("pkill memcached");
}

int bootstrap(std::string path, bool resume) {
    std::cout << "Loading config file..." << std::endl;
    Config conf;
    conf.LoadConfigFile(path);

    std::cout << "Starting NVMM and KVS instances..." << std::endl;
    std::string type = conf.GetKVSType();
    size_t size = conf.GetKVSSize();

    // create KVSs
    for(uint64_t i=0; i<conf.GetPartitionCnt(); i++) {

        // create shelf base
        std::string base=conf.GetShelfBaseForPartition(i);
        std::string cmd = "mkdir -p " + base;
        system(cmd.c_str());
        std::string user=conf.GetShelfUserForPartition(i);

        std::cout << "Partition " << i << ": base " << base << " user " << user << std::endl;

        // if we want to start from fresh, remove previous shelves
        if(!resume)
            reset(base, user);

        // init NVMM
        if(i==0) {
            // must do start for the first time
            start(base, user);
        }
        else {
            restart(base, user);
        }

        // create KVS
        GlobalPtr root;
        int ret = createKVS(type, size, root, base, user);
        if(ret!=0)
            return -1;
        std::stringstream ss;
        ss<<root;

        conf.UpdateRoot(i, ss.str());
    }
    assert(conf.IsValid());
    conf.SaveConfigFile(path);
    std::cout << "Updating config file..." << std::endl;
    conf.PrintConfigFile(path);

    std::cout << "Final cluster settings..." << std::endl;
    Cluster c;
    c.Init(conf);
    c.Print();

    return 0;
}

int replay(std::string type_str, GlobalPtr root, std::string log, std::string base="", std::string user="") {
    KeyValueStore::IndexType type;
    if(type_str=="radixtree") {
        type = KeyValueStore::RADIX_TREE;
    }
    else {
        type = KeyValueStore::HASH_TABLE;
    }

    KeyValueStore *kvs;

    kvs = KeyValueStore::MakeKVS(type, root, base, user);
    if(kvs==nullptr) {
        std::cout << "Failed to open the KVS at " << root << std::endl;
        return -1;
    }

    size_t const max_val_len = 4096;
    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(val_buf, val_len, max_val_len);

    std::ifstream infile(log);
    std::string line;
    while(std::getline(infile, line)) {
        std::string op=line.substr(0,3);
        size_t pos=line.find(' ', 4);
        std::string key=line.substr(4, pos-4);
        std::string val=line.substr(pos+1);
        //std::cout << op << " " << key << " " << val << std::endl;
        if(op=="PUT") {
            int ret = kvs->Put( key.c_str(), key.size(),
                                val.c_str(), val.size());
            if(ret!=0) {
                std::cout << "KVS Put failed" << std::endl;
                std::cout << "  key is: " << key << std::endl;
            }
            // else {
            //     std::cout << "KVS Put succeeded: " << std::endl;
            //     std::cout << "  key is: " << key << std::endl;
            //     std::cout << "  val is: " << val << std::endl;
            // }
        }
        else if(op=="GET") {
            ResetBuf(val_buf, val_len, max_val_len);
            int ret = kvs->Get( key.c_str(), key.size(),
                                val_buf, val_len );
            if(ret!=0) {
                std::cout << "KVS Get failed" << std::endl;
                std::cout << "  key is: " << key << std::endl;
                if(val_len>max_val_len) std::cout << " require val buffer of size " << val_len << std::endl;
            }
            // else {
            //     std::cout << "KVS Get succeeded: " << std::endl;
            //     std::cout << "  key is: " << key << std::endl;
            //     std::cout << "  val is: " << std::string(val_buf, val_len) << std::endl;
            // }
        }
        else if(op=="DEL") {
            int ret = kvs->Del( key.c_str(), key.size() );
            if(ret!=0) {
                std::cout << "KVS Del failed" << std::endl;
                std::cout << "  key is: " << key << std::endl;
            }
            // else {
            //     std::cout << "KVS Del succeeded: " << std::endl;
            //     std::cout << "  key is: " << key << std::endl;
            // }
        }
    }

    delete kvs;
    return 0;
}

int heap_stats(GlobalPtr root, std::string base="", std::string user="") {
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = mm->FindHeap(KeyValueStore::default_heap_id_);
    assert(heap);

    nvmm::ErrorCode ret;
    ret = heap->Open();
    assert(ret==nvmm::NO_ERROR);
    heap->Stats();
    delete heap;
    return 0;
}


int main(int argc, char** argv) {
    if (argc < 2) {
        fprintf(stderr, "usage: kvs {start|reset|create type(radixtree, hashtable) size|scan type root|bootstrap config_path new/resume|start_servers config_path server_path|stop_servers}\n");
        exit(1);
    }

    std::string command = argv[1];

    // commands for a single KVS
    // TODO: pass nvmm config file
    if (command == "start") {
        start();
        return 0;
    }
    else if (command == "reset") {
        reset();
        return 0;
    }
    else if (command == "create") {
        std::string type;
        size_t size;
        if (argc == 4) {
            type = argv[2];
            size = atol(argv[3]);
        }
        else {
            std::cout << "Invalid usage: ./kvs create type size" << std::endl;
            return -1;
        }
        GlobalPtr root;
        return createKVS(type, size, root);
    }
    else if(command == "print") {
        std::string type;
        GlobalPtr root;
        std::string base="";
        std::string user="";
        if (argc>=4) {
            type = argv[2];
            root = str2gptr(argv[3]);
            if(argc>4) {
                base = argv[4];
                user = argv[5];
            }            
        }
        else {
            std::cout << "Invalid usage: ./kvs print type root" << std::endl;
            return -1;
        }

        return printKVS(type, root, base, user);
    }
    else if(command == "scan") {
        std::string type;
        GlobalPtr root;
        std::string base="";
        std::string user="";
        if (argc>=4) {
            type = argv[2];
            root = str2gptr(argv[3]);
            if(argc>4) {
                base = argv[4];
                user = argv[5];
            }
        }
        else {
            std::cout << "Invalid usage: ./kvs scan type root" << std::endl;
            return -1;
        }

        return scanKVS(type, root, base, user);
    }
    else if (command == "put") {
        std::string type;
        GlobalPtr root;
        std::string key;
        std::string val;
        if (argc==6) {
            type = argv[2];
            root = str2gptr(argv[3]);
            key = argv[4];
            val = argv[5];
        }
        else {
            std::cout << "Invalid usage: ./kvs put type root key val" << std::endl;
            return -1;
        }

        return putKVS(type, root, key, val);
    }
    else if (command == "get") {
        std::string type;
        GlobalPtr root;
        std::string key;
        if (argc==5) {
            type = argv[2];
            root = str2gptr(argv[3]);
            key = argv[4];
        }
        else {
            std::cout << "Invalid usage: ./kvs get type root key" << std::endl;
            return -1;
        }

        return getKVS(type, root, key);
    }
    else if (command == "del") {
        std::string type;
        GlobalPtr root;
        std::string key;
        if (argc==5) {
            type = argv[2];
            root = str2gptr(argv[3]);
            key = argv[4];
        }
        else {
            std::cout << "Invalid usage: ./kvs del type root key" << std::endl;
            return -1;
        }

        return delKVS(type, root, key);
    }
    else if (command == "replay") {
        std::string type;
        GlobalPtr root;
        std::string log_path;
        if (argc == 5) {
            type = argv[2];
            root = str2gptr(argv[3]);
            log_path = argv[4];
        }
        else {
            std::cout << "Invalid usage: ./kvs replay type root log_path" << std::endl;
            return -1;
        }
        replay(type, root, log_path);
    }
    // commands for a cluster of KVSes
    else if (command == "bootstrap") {
        std::string path;
        std::string mode="new";
        if (argc >=3) {
            path = argv[2];
            if(argc==4)
                mode = argv[3];
        }
        else {
            std::cout << "Invalid usage: ./kvs bootstrap config_path new/resume" << std::endl;
            return -1;
        }
        return bootstrap(path, mode=="resume"?true:false);
    }
    else if (command == "start_servers") {
        std::string config_path, server_path, prefix="";
        if (argc >= 4) {
            config_path = argv[2];
            server_path = argv[3];
            if(argc==5)
                prefix = argv[4];
        }
        else {
            std::cout << "Invalid usage: ./kvs start_servers config_path server_path" << std::endl;
            return -1;
        }
        start_servers(config_path, server_path, prefix);
    }
    else if (command == "stop_servers") {
        stop_servers();
    }
    else if(command == "heap_stats") {
        GlobalPtr root;
        if (argc==3) {
            root = str2gptr(argv[2]);
        }
        else {
            std::cout << "Invalid usage: ./kvs heap_stats root" << std::endl;
            return -1;
        }

        return heap_stats(root);
    }
    return 0;
}
