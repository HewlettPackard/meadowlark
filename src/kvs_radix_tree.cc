/*
 *  (c) Copyright 2016-2017 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <stddef.h>
#include <stdint.h>
#include <iostream>
#include <string>
#include <string.h> // memset, memcpy

#include "nvmm/error_code.h"
#include "nvmm/global_ptr.h"
#include "nvmm/shelf_id.h"
#include "nvmm/memory_manager.h"
#include "nvmm/heap.h"

#include "radixtree/radixtree_libpmem.h"
#include "kvs_radix_tree.h"

namespace radixtree {

KVSRadixTree::KVSRadixTree(Gptr root)
    : mmgr_(Mmgr::GetInstance()), emgr_(Emgr::GetInstance()), heap_(nullptr),
      tree_(nullptr), root_(root) {
    int ret = Open();
    assert(ret==0);
}

KVSRadixTree::~KVSRadixTree() {
    int ret = Close();
    assert(ret==0);
}

int KVSRadixTree::Open() {
    nvmm::ErrorCode ret;

    // find the heap
    heap_ = mmgr_->FindHeap(heap_id_);
    if(!heap_) {
        ret = mmgr_->CreateHeap(heap_id_, heap_size_);
        if(ret!=nvmm::NO_ERROR)
            return -1;
        heap_ = mmgr_->FindHeap(heap_id_);
    }
    assert(heap_);

    // open the heap
    ret = heap_->Open();
    if(ret!=nvmm::NO_ERROR) {
        delete heap_;
        return -1;
    }

    // create/open the radixtree
#ifdef DEBUG
    if(!root_)
        std::cout << "create a new radix tree: ";
    else
        std::cout << "open an existing radix tree: ";
#endif
    tree_ = new RadixTree(mmgr_, heap_, root_);
    if (!tree_) {
        delete heap_;
        return -1;
    }
    root_ = tree_->get_root();
#ifdef DEBUG
    std::cout << (uint64_t)root_ << std::endl;
#endif
    return 0;
}

int KVSRadixTree::Close() {
    nvmm::ErrorCode ret;

    // close the radix tree
    if (tree_) {
#ifdef DEBUG
        std::cout << "close the radix tree: " << root_;
#endif
        delete tree_;
        tree_ = nullptr;
    }

    // close the heap
    if (heap_ && heap_->IsOpen()) {
        ret = heap_->Close();
        if(ret!=nvmm::NO_ERROR)
            return -1;
        delete heap_;
        heap_ = nullptr;
    }

    return 0;
}

int KVSRadixTree::Put (char const *key, size_t const key_len,
                       char const *val, size_t const val_len) {
    if (key_len > kMaxKeyLen)
        return -1;
    if (val_len > kMaxValLen)
        return -1;

    Eop op(emgr_);

    RadixTree::key_type key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    memcpy((char*)&key_buf, key, key_len);

    Gptr val_gptr = heap_->Alloc(op, val_len);
    if (!val_gptr)
        return -1;

    ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);

    val_ptr->size = val_len;
    memcpy((char*)val_ptr->val, (char const *)val, val_len);
    pmem_persist(val_ptr, sizeof(ValBuf)+val_len);

    val_gptr = tree_->put(key_buf, (int)key_len, val_gptr);
    if (val_gptr) {
#ifdef DEBUG
        std::cout << "  successfully updated "
                  << std::string(key, key_len) << " = " << std::string(val, val_len);
        ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
        std::cout << "  (old value " << std::string(val_ptr->val, val_ptr->size) << ")";

        std::cout << std::endl;
        std::cout << "  delayed free memory at " << val_gptr << std::endl;
#endif
        heap_->Free(op, val_gptr);
    }
    else {
#ifdef DEBUG
        std::cout << "  successfully inserted "
                  << std::string(key, key_len) << " = " << std::string(val, val_len) << std::endl;
#endif
    }

    return 0;
}

int KVSRadixTree::Get (char const *key, size_t const key_len,
                       char *val, size_t &val_len) {
    if (key_len > kMaxKeyLen)
        return -1;
    if (val_len > kMaxValLen)
        return -1;

    Eop op(emgr_);

    RadixTree::key_type key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    memcpy((char*)&key_buf, key, key_len);

    Gptr val_gptr = tree_->get(key_buf, (int)key_len);
    if (!val_gptr)
        return -1;

    ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
    if(val_len < val_ptr->size)
        return -1;
    val_len = val_ptr->size;
    memcpy((char*)val, (char*)val_ptr->val, val_len);
#ifdef DEBUG
    std::cout << "  successfully fetched "
              << std::string(key, key_len) << " -> " << std::string(val, val_len) << std::endl;
#endif
    return 0;
}

int KVSRadixTree::Del (char const *key, size_t const key_len) {
    if (key_len > kMaxKeyLen)
        return -1;

    Eop op(emgr_);

    RadixTree::key_type key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    memcpy((char*)&key_buf, key, key_len);

    Gptr val_gptr = tree_->destroy(key_buf, (int)key_len);
    if (val_gptr) {
#ifdef DEBUG
        std::cout << "  successfully deleted " << std::string(key, key_len);
        ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
        std::cout << " = " << std::string(val_ptr->val, val_ptr->size);

        std::cout << std::endl;
        std::cout << "  delayed free memory at " << val_gptr << std::endl;
#endif
        heap_->Free(op, val_gptr);
        return 0;
    }
    else {
#ifdef DEBUG
        std::cout << "  not found: "
                  << std::string(key, key_len) << std::endl;
#endif
        return -1;
    }
}

} // namespace radixtree
