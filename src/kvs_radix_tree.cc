/*
 *  (c) Copyright 2016-2017 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <stddef.h>
#include <stdint.h>
#include <iostream>
#include <string>
#include <string.h> // memset, memcpy

#include "nvmm/error_code.h"
#include "nvmm/global_ptr.h"
#include "nvmm/shelf_id.h"
#include "nvmm/memory_manager.h"
#include "nvmm/heap.h"

#include "radixtree/radixtree_libpmem.h"
#include "kvs_radix_tree.h"

namespace radixtree {

KVSRadixTree::KVSRadixTree(Gptr root)
    : mmgr_(Mmgr::GetInstance()), emgr_(Emgr::GetInstance()), heap_(nullptr),
      tree_(nullptr), root_(root) {
    int ret = Open();
    assert(ret==0);
}

KVSRadixTree::~KVSRadixTree() {
    int ret = Close();
    assert(ret==0);
}

int KVSRadixTree::Open() {
    nvmm::ErrorCode ret;

    // find the heap
    heap_ = mmgr_->FindHeap(heap_id_);
    if(!heap_) {
        ret = mmgr_->CreateHeap(heap_id_, heap_size_);
        if(ret!=nvmm::NO_ERROR)
            return -1;
        heap_ = mmgr_->FindHeap(heap_id_);
    }
    assert(heap_);

    // open the heap
    ret = heap_->Open();
    if(ret!=nvmm::NO_ERROR) {
        delete heap_;
        return -1;
    }

    // create/open the radixtree
// #ifdef DEBUG
//     if(!root_)
//         std::cout << "create a new radix tree: ";
//     else
//         std::cout << "open an existing radix tree: ";
// #endif
    tree_ = new RadixTree(mmgr_, heap_, root_);
    if (!tree_) {
        delete heap_;
        return -1;
    }
    root_ = tree_->get_root();
// #ifdef DEBUG
//     std::cout << (uint64_t)root_ << std::endl;
// #endif
    return 0;
}

int KVSRadixTree::Close() {
    nvmm::ErrorCode ret;

    // close the radix tree
    if (tree_) {
// #ifdef DEBUG
//         std::cout << "close the radix tree: " << root_;
// #endif
        delete tree_;
        tree_ = nullptr;
    }

    // close the heap
    if (heap_ && heap_->IsOpen()) {
        ret = heap_->Close();
        if(ret!=nvmm::NO_ERROR)
            return -1;
        delete heap_;
        heap_ = nullptr;
    }

    // delete all iters
    for (auto iter:iters_) {
        if (iter)
            delete iter;
    }
    return 0;
}

int KVSRadixTree::Put (char const *key, size_t const key_len,
                       char const *val, size_t const val_len) {
    if (key_len > kMaxKeyLen)
        return -1;
    if (val_len > kMaxValLen)
        return -1;

    Eop op(emgr_);

    RadixTree::key_type key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    memcpy((char*)&key_buf, key, key_len);

    Gptr val_gptr = heap_->Alloc(op, val_len);
    if (!val_gptr)
        return -1;

    ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);

    val_ptr->size = val_len;
    memcpy((char*)val_ptr->val, (char const *)val, val_len);
    pmem_persist(val_ptr, sizeof(ValBuf)+val_len);

    val_gptr = tree_->put(key_buf, (int)key_len, val_gptr);
    if (val_gptr) {
// #ifdef DEBUG
//         std::cout << "  successfully updated "
//                   << std::string(key, key_len) << " = " << std::string(val, val_len);
//         ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
//         std::cout << "  (old value " << std::string(val_ptr->val, val_ptr->size) << ")";

//         std::cout << std::endl;
//         std::cout << "  delayed free memory at " << val_gptr << std::endl;
// #endif
        heap_->Free(op, val_gptr);
    }
    else {
// #ifdef DEBUG
//         std::cout << "  successfully inserted "
//                   << std::string(key, key_len) << " = " << std::string(val, val_len) << std::endl;
// #endif
    }

    return 0;
}

int KVSRadixTree::Get (char const *key, size_t const key_len,
                       char *val, size_t &val_len) {
    if (key_len > kMaxKeyLen)
        return -1;
    if (val_len > kMaxValLen)
        return -1;

    Eop op(emgr_);

    RadixTree::key_type key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    memcpy((char*)&key_buf, key, key_len);

    Gptr val_gptr = tree_->get(key_buf, (int)key_len);
    if (!val_gptr)
        return -1;

    ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
    if(val_len < val_ptr->size)
        return -1;
    val_len = val_ptr->size;
    memcpy((char*)val, (char*)val_ptr->val, val_len);
// #ifdef DEBUG
//     std::cout << "  successfully fetched "
//               << std::string(key, key_len) << " -> " << std::string(val, val_len) << std::endl;
// #endif
    return 0;
}

int KVSRadixTree::Del (char const *key, size_t const key_len) {
    if (key_len > kMaxKeyLen)
        return -1;

    Eop op(emgr_);

    RadixTree::key_type key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    memcpy((char*)&key_buf, key, key_len);

    Gptr val_gptr = tree_->destroy(key_buf, (int)key_len);
    if (val_gptr) {
// #ifdef DEBUG
//         std::cout << "  successfully deleted " << std::string(key, key_len);
//         ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
//         std::cout << " = " << std::string(val_ptr->val, val_ptr->size);

//         std::cout << std::endl;
//         std::cout << "  delayed free memory at " << val_gptr << std::endl;
// #endif
        heap_->Free(op, val_gptr);
        return 0;
    }
    else {
// #ifdef DEBUG
//         std::cout << "  not found: "
//                   << std::string(key, key_len) << std::endl;
// #endif
        return -1;
    }
}

int KVSRadixTree::Scan (
    int &iter_handle,
    char *key, size_t &key_len,
    char *val, size_t &val_len,
    char const *begin_key, size_t const begin_key_len,
    bool const begin_key_inclusive,
    char const *end_key, size_t const end_key_len,
    bool const end_key_inclusive) {

    if (begin_key_len > kMaxKeyLen || end_key_len > kMaxKeyLen)
        return -1;
    if (key_len > kMaxKeyLen)
        return -1;
    if (val_len > kMaxValLen)
        return -1;

    RadixTree::key_type begin_key_buf;
    memset(&begin_key_buf, 0, sizeof(begin_key_buf));
    memcpy((char*)&begin_key_buf, begin_key, begin_key_len);

    RadixTree::key_type end_key_buf;
    memset(&end_key_buf, 0, sizeof(end_key_buf));
    memcpy((char*)&end_key_buf, end_key, end_key_len);

    Eop op(emgr_);

    RadixTree::key_type key_buf;
    int key_buf_len = sizeof(key_buf);
    memset(&key_buf, 0, sizeof(key_buf));
    RadixTree::Iter *iter=new RadixTree::Iter();
    Gptr val_gptr;
    int ret = tree_->scan(*iter,
                          key_buf, key_buf_len, val_gptr,
                          begin_key_buf, (int)begin_key_len, begin_key_inclusive,
                          end_key_buf, (int)end_key_len, end_key_inclusive);
    if (ret!=0)
        return -1; // TODO: better error codes

    // copy key
    key_len = key_buf_len;
    memcpy((char*)key, (char*)key_buf, key_len);
    // copy val
    ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
    if(val_len < val_ptr->size)
        return -1;
    val_len = val_ptr->size;
    memcpy((char*)val, (char*)val_ptr->val, val_len);
// #ifdef DEBUG
//     std::cout << "  SCAN: successfully fetched "
//               << std::string(key, key_len) << " -> "
//               << std::string(val, val_len)
//               << std::endl;
// #endif

    // assign iter handle
    std::lock_guard<std::mutex> lock(mutex_);
    iters_.push_back(iter);
    iter_handle = (int)(iters_.size()-1);
    return 0;
}

int KVSRadixTree::GetNext(int iter_handle,
                          char *key, size_t &key_len,
                          char *val, size_t &val_len) {
    if (key_len > kMaxKeyLen)
        return -1;
    if (val_len > kMaxValLen)
        return -1;
    if (iter_handle <0 || iter_handle >= (int)iters_.size())
        return -1;

    RadixTree::key_type key_buf;
    int key_buf_len = sizeof(key_buf);
    memset(&key_buf, 0, sizeof(key_buf));
    Gptr val_gptr;

    RadixTree::Iter *iter;
    {
        //std::lock_guard<std::mutex> lock(mutex_);
        iter = iters_[iter_handle];
    }
    int ret = tree_->get_next(*iter,
                              key_buf, key_buf_len, val_gptr);
    if (ret!=0)
        return -1; // TODO: better error codes

    // copy key
    key_len = key_buf_len;
    memcpy((char*)key, (char*)key_buf, key_len);
    // copy val
    ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
    if(val_len < val_ptr->size)
        return -1;
    val_len = val_ptr->size;
    memcpy((char*)val, (char*)val_ptr->val, val_len);
// #ifdef DEBUG
//     std::cout << "  GET_NEXT: successfully fetched "
//               << std::string(key, key_len) << " -> "
//               << std::string(val, val_len)
//               << std::endl;
// #endif
    return 0;
}

} // namespace radixtree
