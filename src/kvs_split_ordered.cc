/*
 *  (c) Copyright 2016-2021 Hewlett Packard Enterprise Development Company LP.
 *
 *  This software is available to you under a choice of one of two
 *  licenses. You may choose to be licensed under the terms of the
 *  GNU Lesser General Public License Version 3, or (at your option)
 *  later with exceptions included below, or under the terms of the
 *  MIT license (Expat) available in COPYING file in the source tree.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */


#include <stddef.h>
#include <stdint.h>
#include <iostream>
#include <string>
#include <string.h> // memset, memcpy

#include "nvmm/error_code.h"
#include "nvmm/global_ptr.h"
#include "nvmm/shelf_id.h"
#include "nvmm/memory_manager.h"
#include "nvmm/heap.h"

#include "nvmm/fam.h"
#include "kvs_split_ordered.h"

namespace radixtree {

KVSSplitOrdered::KVSSplitOrdered(Gptr descriptor, std::string base, std::string user, size_t heap_size, nvmm::PoolId heap_id, SplitOrderedMetrics* metrics)
    : heap_id_(heap_id), heap_size_(heap_size),
      mmgr_(Mmgr::GetInstance()), emgr_(Emgr::GetInstance()), heap_(nullptr),
      sol_(nullptr), descriptor_(descriptor), metrics_(metrics) {
    nvmm::StartNVMM(base, user);
    int ret = Open();
    assert(ret==0);
}

KVSSplitOrdered::~KVSSplitOrdered() {
    int ret = Close();
    assert(ret==0);
}

void KVSSplitOrdered::Maintenance() {
    heap_->OfflineFree();
}

int KVSSplitOrdered::Open() {
    nvmm::ErrorCode ret;

    // find the heap
    heap_ = mmgr_->FindHeap(heap_id_);
    if(!heap_) {
        ret = mmgr_->CreateHeap(heap_id_, heap_size_);
        if(ret!=nvmm::NO_ERROR)
            return -1;
        heap_ = mmgr_->FindHeap(heap_id_);
    }
    assert(heap_);

    // open the heap
    ret = heap_->Open();
    if(ret!=nvmm::NO_ERROR) {
        delete heap_;
        return -1;
    }

    // create/open the split ordered list
#ifdef DEBUG
    if(!descriptor_)
        std::cout << "create a new split ordered list: ";
    else
        std::cout << "open an existing split ordered list: ";
#endif
    sol_ = new SplitOrderedList(mmgr_, heap_, metrics_, descriptor_);
    if (!sol_) {
        delete heap_;
        return -1;
    }
    descriptor_ = sol_->get_descriptor();
#ifdef DEBUG
    std::cout << (uint64_t)descriptor_ << std::endl;
#endif
    return 0;
}

int KVSSplitOrdered::Close() {
    nvmm::ErrorCode ret;

    // close the split ordered list
    if (sol_) {
#ifdef DEBUG
        std::cout << "close the split ordered list: " << descriptor_;
#endif
        delete sol_;
        sol_ = nullptr;
    }

    // close the heap
    if (heap_ && heap_->IsOpen()) {
        ret = heap_->Close();
        if(ret!=nvmm::NO_ERROR)
            return -1;
        delete heap_;
        heap_ = nullptr;
    }

    return 0;
}

int KVSSplitOrdered::Put (char const *key, size_t const key_len,
                       char const *val, size_t const val_len) {
    if (key_len > kMaxKeyLen)
        return -1;
    if (val_len > kMaxValLen)
        return -1;

    Eop op(emgr_);

    SplitOrderedList::ByteKey key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    memcpy((char*)&key_buf, key, key_len);

    Gptr val_gptr = heap_->Alloc(op, val_len+sizeof(ValBuf));
    if (!val_gptr.IsValid())
        return -1;

    ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);

    val_ptr->size = val_len;
    memcpy((char*)val_ptr->val, (char const *)val, val_len);
    fam_persist(val_ptr, sizeof(ValBuf)+val_len);

    Gptr old_val_gptr;
    int success = sol_->InsertOrUpdate(op, key_buf, (int)key_len, val_gptr, &old_val_gptr);
    if (!success) {
        return -1;
    }
    if (old_val_gptr) {
#ifdef DEBUG
        std::cout << "  successfully updated "
                  << std::string(key, key_len) << " = " << std::string(val, val_len);
        ValBuf *old_val_ptr = (ValBuf*)mmgr_->GlobalToLocal(old_val_gptr);
        std::cout << "  (old value " << std::string(old_val_ptr->val, old_val_ptr->size) << ")";

        std::cout << std::endl;
        std::cout << "  delayed free memory at " << old_val_gptr << std::endl;
#endif
        heap_->Free(op, old_val_gptr);
    }
    else {
#ifdef DEBUG
        std::cout << "  successfully inserted "
                  << std::string(key, key_len) << " = " << std::string(val, val_len) << std::endl;
#endif
    }

    return 0;
}

int KVSSplitOrdered::Get (char const *key, size_t const key_len,
                       char *val, size_t &val_len) {
    if (key_len > kMaxKeyLen)
        return -1;

    Eop op(emgr_);

    SplitOrderedList::ByteKey key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    memcpy((char*)&key_buf, key, key_len);

    Gptr val_gptr = sol_->Find(op, key_buf, (int)key_len);
    if (!val_gptr)
        return -1;

    ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
    fam_invalidate(&val_ptr->size, sizeof(size_t));
    size_t val_size = val_ptr->size;
    if(val_len < val_size) {
        std::cout << "  val buffer is too small: " << val_len << " -> " << val_size << std::endl;
        val_len = val_size;
        return -1;
    }
    val_len = val_size;
    fam_invalidate(&val_ptr->val, val_len);
    memcpy((char*)val, (char*)val_ptr->val, val_len);
#ifdef DEBUG
    std::cout << "  successfully fetched "
              << std::string(key, key_len) << " -> " << std::string(val, val_len) << std::endl;
#endif
    return 0;
}

int KVSSplitOrdered::Del (char const *key, size_t const key_len) {
    if (key_len > kMaxKeyLen)
        return -1;

    Eop op(emgr_);

    SplitOrderedList::ByteKey key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    memcpy((char*)&key_buf, key, key_len);

    Gptr val_gptr;
    int success = sol_->Delete(op, key_buf, (int)key_len, &val_gptr);
    if (success) {
#ifdef DEBUG
        std::cout << "  successfully deleted " << std::string(key, key_len);
        ValBuf *val_ptr = (ValBuf*)mmgr_->GlobalToLocal(val_gptr);
        std::cout << " = " << std::string(val_ptr->val, val_ptr->size);

        std::cout << std::endl;
        std::cout << "  delayed free memory at " << val_gptr << std::endl;
#endif
        heap_->Free(op, val_gptr);
        return 0;
    }
    else {
#ifdef DEBUG
        std::cout << "  not found: "
                  << std::string(key, key_len) << std::endl;
#endif
        return -1;
    }
}

void KVSSplitOrdered::ReportMetrics() {
    if (metrics_) {
        metrics_->Report();
    }
}

int KVSSplitOrdered::FindOrCreate (char const *key, size_t const key_len,
                       char const *val, size_t const val_len,
            char *ret_val, size_t &ret_len)
{
    return 0;
}


} // namespace radixtree
