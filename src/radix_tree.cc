/*
 *  (c) Copyright 2016-2017 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <cstring>

#include "nvmm/memory_manager.h"
#include "nvmm/heap.h"

#include "radixtree/radix_tree.h"
#include "radixtree/radixtree_libpmem.h"
#include "radixtree/radixtree_fam_atomic.h"


namespace radixtree {

struct RadixTree::Node {
public:
    RadixTree::key_type key;
    int                 prefix_size;
    Gptr            child[256];
    Gptr            value;
};


static inline
Gptr cas64(Gptr* target, Gptr old_value, Gptr new_value) {
    return fam_atomic_u64_compare_and_store((uint64_t*)target, (uint64_t)old_value, (uint64_t)new_value);
}

RadixTree::RadixTree(Mmgr *Mmgr, Heap *Heap, Gptr Root)
    : mmgr(Mmgr), heap(Heap), root(Root)
{
    assert(mmgr!=NULL);
    assert(heap!=NULL);
    if (root==0) {
        root = heap->Alloc(sizeof(Node));
        assert(root.IsValid());
        Node *root_node = (Node*)toLocal(root);
        assert(root_node);
        root_node->prefix_size = 0;
        for (int i=0; i<256; i++) {
            root_node->child[i] = 0;
        }
        root_node->value = 0;
        pmem_persist(root_node, sizeof(Node));
    }
}

RadixTree::~RadixTree() {}

//********************************
// Common Helpers                *
//********************************
void* RadixTree::toLocal(const Gptr &gptr) {
  return mmgr->GlobalToLocal(gptr);
}

Gptr RadixTree::get_root() {
    return root;
}

void RadixTree::list(std::function<void(const key_type&, const int, Gptr)> f) {
    Gptr p = root;
    recursive_list(p, f);
}

void RadixTree::recursive_list(Gptr parent, std::function<void(const key_type&, const int, Gptr)> f) {
    if (parent==0)
        return;

    Node* n = (Node*)toLocal(parent);
    assert(n);
    pmem_invalidate(n, sizeof(Node));

#ifdef DEBUG_VERBOSE
    printf("[%ld: %s (%d)]\n", parent, n->key, n->prefix_size);
    if (n->value !=0 )
        printf("  * -> %ld\n",  n->value);
    for (int j=0; j<256; j++)
        if (n->child[j]!=0)
            printf("  %c (0x%x) -> %ld\n", j, j, n->child[j]);
#endif
    if (n->value !=0 ) {
        f(n->key, n->prefix_size, n->value);
    }

    for (int i=0; i<256; i++)
        recursive_list(n->child[i], f);
}

Gptr RadixTree::put(const key_type& key, const int key_size, Gptr value) {
    assert(key_size>0 && key_size<=(int)sizeof(key_type));

    Gptr *p = NULL;
    Gptr q = root;

    Gptr new_leaf_ptr = 0;
    Gptr intermediate_node_ptr = 0;
    Node* intermediate_node;
    int prefix_size, existing;
    for (;;) {
        // Find current correct insertion point:
        while (q != 0) {
            Node* n = (Node*)toLocal(q);
            assert(n);
            pmem_invalidate(n, sizeof(Node));

            int i;
            for (i=0; i<std::min(key_size, n->prefix_size); i++)
                if (key[i] != n->key[i])
                    break;

            if (i<n->prefix_size) {
                // does not match the entire prefix, we have to do a split
                prefix_size = i;
                existing    = n->key[i];
                break;
                // will always go to case 2
            }
            else {
                // the key so far has matched the entire prefix
                // assert(key_size >= n->prefix_size);
                // assert(i==n->prefix_size);
                if (key_size == i) {
                    // match the entire prefix
                    heap->Free(intermediate_node_ptr);
                    heap->Free(new_leaf_ptr);
                    if (n->value != 0) {
                        // the key exists
                        //return false;

                        // TODO: fam_atomic_write instead of cas?
                        p = &n->value;
                        q = *p;
                        for(;;) {
                            Gptr seen_q = cas64(p, q, value);
                            if (seen_q == q) {
                                return q;
                            }
                            q = seen_q;
                        }
                    }
                    else {
                        // the key does not exist
                        // just update the value pointer
                        // p = &n->value;
                        // q = 0;

                        // Gptr seen_q = cas64(p, q, value);
                        // if (seen_q == q)
                        //     return true;
                        // else
                        //     return false;

                        // TODO: fam_atomic_write instead of cas?
                        p = &n->value;
                        q = *p;
                        for(;;) {
                            Gptr seen_q = cas64(p, q, value);
                            if (seen_q == q) {
                                return q;
                            }
                            q = seen_q;
                        }
                    }
                }
                else {
                    // the key is longer
                    p = &n->child[(uint)key[i]];
                    q = *p;
                    // will always go to case 1 if q==0
                }
            }
        }

        // case 1:
        // no split but need to insert a new leaf node:
        if (q==0) {
            if (new_leaf_ptr==0) {
                new_leaf_ptr = heap->Alloc(sizeof(Node));
                Node*    new_leaf     = (Node*)toLocal(new_leaf_ptr);
                assert(new_leaf);
                std::memcpy(&new_leaf->key, key, key_size);
                new_leaf->prefix_size = key_size;
                new_leaf->value = value;
                pmem_persist(new_leaf, sizeof(Node));
            }

            Gptr seen_q = cas64(p, q, new_leaf_ptr);
            if (seen_q == q) {
                heap->Free(intermediate_node_ptr);
                //return true;
                return 0;
            }
            q = seen_q;
            continue;
        }

        // case 2:
        // split
        if (intermediate_node_ptr == 0) {
            intermediate_node_ptr = heap->Alloc(sizeof(Node));
            intermediate_node = (Node*)toLocal(intermediate_node_ptr);
            assert(intermediate_node);
            // we don't just copy the current common prefix because the prefix at this node may
            // change when the final pointer swing fails
            // so it is easier to just copy the entire key and update the prefix_size later
            std::memcpy(&intermediate_node->key, key, key_size);
            for (int i=0; i<256; i++)
                intermediate_node->child[i] = 0;

            if (prefix_size == key_size)
                intermediate_node->value = value;
            else {
                if (new_leaf_ptr==0) {
                    new_leaf_ptr = heap->Alloc(sizeof(Node));
                    Node*   new_leaf     = (Node*)toLocal(new_leaf_ptr);
                    assert(new_leaf);
                    std::memcpy(&new_leaf->key, key, key_size);
                    new_leaf->prefix_size = key_size;
                    new_leaf->value = value;
                    pmem_persist(new_leaf, sizeof(Node));
                }
                intermediate_node->child[(uint)key[prefix_size]] = new_leaf_ptr;
            }
        }
        // link q
        intermediate_node->prefix_size = prefix_size;
        intermediate_node->child[existing] = q;
        pmem_persist(intermediate_node, sizeof(Node));

        Gptr seen_q = cas64(p, q, intermediate_node_ptr);
        if (seen_q == q)
            return 0;
        q = seen_q;
    }
}



Gptr RadixTree::get(const key_type& key, const int key_size) {
    assert(key_size>0 && key_size<=(int)sizeof(key_type));
    Gptr* p = NULL;
    Gptr q = root;

    while (q != 0) {
        Node* n = (Node*)toLocal(q);
        assert(n);
        pmem_invalidate(n, sizeof(Node));

        int result = memcmp(key, n->key, std::min(n->prefix_size, key_size));
        if (result != 0)
            return 0;

        if (n->prefix_size == key_size)
            return n->value;

        // assert(n->prefix_size<key_size);
        p = &n->child[(uint)key[n->prefix_size]];
        q = *p;
    }

    return 0;
}



Gptr RadixTree::destroy(const key_type& key, const int key_size) {
    assert(key_size>0 && key_size<=(int)sizeof(key_type));
    Gptr* p = NULL;
    Gptr q = root;

    while (q != 0) {
        Node* n = (Node*)toLocal(q);
        assert(n);
        pmem_invalidate(n, sizeof(Node));

        int result = memcmp(key, n->key, std::min(n->prefix_size, key_size));
        if (result != 0)
            return 0;

        if (n->prefix_size == key_size) {
            // TODO: fam_atomic_write instead of cas?
            p = &n->value;
            q = *p;
            for(;;) {
                Gptr seen_q = cas64(p, q, 0);
                if (seen_q == q) {
                    return q;
                }
                q = seen_q;
            }
        }

        p = &n->child[(int)key[n->prefix_size]];
        q = *p;
    }

    return 0;
}



} // end namespace bold
