/*
 *  (c) Copyright 2016-2017, 2021 Hewlett Packard Enterprise Development Company LP.
 *
 *  This software is available to you under a choice of one of two
 *  licenses. You may choose to be licensed under the terms of the
 *  GNU Lesser General Public License Version 3, or (at your option)
 *  later with exceptions included below, or under the terms of the
 *  MIT license (Expat) available in COPYING file in the source tree.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <assert.h>
#include <map>
#include <iostream>

#include "cluster/config.h"
#include "partition_manager.h"

namespace radixtree {

PartitionManager::PartitionManager(Config *config) {
    assert(config && config->IsValid());
    config_=config;
}

PartitionManager::~PartitionManager() {
}

void PartitionManager::Init() {
    partition_cnt_ = config_->GetPartitionCnt();
    node_cnt_ = config_->GetNodeCnt();
    replication_scheme_ = config_->GetReplicationScheme();
    replication_factor_ = config_->GetReplicationFactor();

    // load kvs info from config
    for(auto &p:config_->GetPartitions()) {
        partition_[p.first]=p.second;
    }

    // set up partition2node
    if(replication_scheme_ == Config::ReplicationScheme::NO_REPLICATION) {
        return;
    }
    else if(replication_scheme_ == Config::ReplicationScheme::MASTER_SLAVE) {
        for(PartitionID pid=0; pid<partition_cnt_; pid++) {
            for(uint64_t r=0; r<replication_factor_; r++) {
                NodeID nid = pid*replication_factor_ + r;
                partition2node_[pid].push_back(nid);
            }
        }
    }
    else if(replication_scheme_ == Config::ReplicationScheme::DYNAMO) {
        for(PartitionID pid=0; pid<partition_cnt_; pid++) {
            for(uint64_t r=0; r<replication_factor_; r++) {
                NodeID nid = (pid + r)%node_cnt_;
                partition2node_[pid].push_back(nid);
            }
        }
    }
    else if(replication_scheme_ == Config::ReplicationScheme::MODC) {
        PartitionID pid=0;
        for(uint64_t r=0; r<replication_factor_; r++) {
            NodeID nid = r%node_cnt_;
            partition2node_[pid].push_back(nid);
        }
    }

    // set up node2partition
    if(replication_scheme_ == Config::ReplicationScheme::NO_REPLICATION) {
        return;
    }
    else if(replication_scheme_ == Config::ReplicationScheme::MASTER_SLAVE) {
        for(PartitionID pid=0; pid<partition_cnt_; pid++) {
            for(uint64_t r=0; r<replication_factor_; r++) {
                NodeID nid = pid*replication_factor_ + r;
                node2partition_[nid].push_back(pid);
            }
        }
    }
    else if(replication_scheme_ == Config::ReplicationScheme::DYNAMO) {
        for(NodeID nid=0; nid<node_cnt_; nid++) {
            for(uint64_t r=0; r<replication_factor_; r++) {
                PartitionID pid = (nid - r + partition_cnt_)%partition_cnt_;
                node2partition_[nid].push_back(pid);
            }
        }
    }
    else if(replication_scheme_ == Config::ReplicationScheme::MODC) {
        PartitionID pid=0;
        for(NodeID nid=0; nid<node_cnt_; nid++) {
            node2partition_[nid].push_back(pid);
        }
    }
}

NodeID PartitionManager::FindNode(PartitionID p) {
    if(replication_scheme_ == Config::ReplicationScheme::NO_REPLICATION) {
        return (NodeID)p;
    }
    else {
        auto found = partition2node_.find(p);
        if(found!=partition2node_.end()) {
            return found->second[0];
        }
        else
            return (NodeID)-1;
    }
}

std::vector<NodeID> PartitionManager::FindNodes(PartitionID p) {
    if(replication_scheme_ == Config::ReplicationScheme::NO_REPLICATION) {
        return std::vector<NodeID>{(NodeID)p};
    }
    else {
        auto found = partition2node_.find(p);
        if(found!=partition2node_.end()) {
            return found->second;
        }
        else
            return std::vector<NodeID>();
    }
}

std::vector<KVS> PartitionManager::FindPartitionsByNode(NodeID n) {
    std::vector<KVS> ret;
    if(replication_scheme_ == Config::ReplicationScheme::NO_REPLICATION) {
        ret.push_back(partition_[(PartitionID)n]);
    }
    else {
        if(node2partition_.find(n)!=node2partition_.end()) {
            for(auto const &p:node2partition_[n]) {
                ret.push_back(partition_[p]);
            }
        }
    }
    return ret;
}


void PartitionManager::Print() {
    std::cout << "PartitionManager " << std::endl;
    std::cout << "- Partitions" << std::endl;
    for(auto &p:partition_) {
        std::cout << " - Partition " << p.first << ": " << std::endl;
        for(auto &kvs:p.second) {
            std::cout << "    " << kvs.first << ": " << kvs.second << std::endl;
        }
    }
    std::cout << "- Partition -> Node " << std::endl;
    for(auto partition:partition2node_) {
        std::cout << " - Partition " << partition.first << " -> [ ";
        for(auto node:partition.second) {
            std::cout << node << " ";
        }
        std::cout << "]" << std::endl;
    }
    std::cout << "- Node -> Partition " << std::endl;
    for(auto node:node2partition_) {
        std::cout << " - Node " << node.first << " -> [ ";
        for(auto partition:node.second) {
            std::cout << partition << " ";
        }
        std::cout << "]" << std::endl;
    }
}

} // namespace radixtree
