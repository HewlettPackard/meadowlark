/*
 *  (c) Copyright 2016-2017, 2021 Hewlett Packard Enterprise Development Company LP.
 *
 *  This software is available to you under a choice of one of two
 *  licenses. You may choose to be licensed under the terms of the
 *  GNU Lesser General Public License Version 3, or (at your option)
 *  later with exceptions included below, or under the terms of the
 *  MIT license (Expat) available in COPYING file in the source tree.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <assert.h>
#include <map>
#include <iostream>
#include <vector>

#include "cluster/config.h"
#include "node_manager.h"

namespace radixtree {

NodeManager::NodeManager(Config *config) {
    assert(config && config->IsValid());
    config_=config;
}

NodeManager::~NodeManager() {
}

void NodeManager::Init() {
    node_cnt_ = config_->GetNodeCnt();
    server_cnt_ = config_->GetServerCnt();
    replication_scheme_ = config_->GetReplicationScheme();
    starting_port_ = config_->GetStartingPort();
    replication_factor_ = config_->GetReplicationFactor();

    // set up nodes (ports)
    if(replication_scheme_ == Config::ReplicationScheme::NO_REPLICATION ||
       replication_scheme_ == Config::ReplicationScheme::MASTER_SLAVE ||
       replication_scheme_ == Config::ReplicationScheme::MODC) {
        // 1 partition per node
        for(NodeID nid=0; nid<node_cnt_; nid++) {
            std::vector<Port> ports;
            ports.push_back(starting_port_+nid);
            node_[nid]=Node(ports);
        }
    }
    else if(replication_scheme_ == Config::ReplicationScheme::DYNAMO) {
        // 1+ partitions per node
        for(NodeID nid=0; nid<node_cnt_; nid++) {
            std::vector<Port> ports;
            for(uint64_t i=0; i<replication_factor_; i++) {
                ports.push_back(starting_port_+nid*replication_factor_+i);
            }
            node_[nid]=Node(ports);
        }
    }

    // set up node to server and server to node mapping
    if(replication_scheme_ == Config::ReplicationScheme::NO_REPLICATION) {
        return;
    }
    else {
        for(NodeID nid=0; nid<node_cnt_; nid++) {
            ServerID sid = nid%server_cnt_;
            node2server_[nid] = sid;
            server2node_[sid].push_back(nid);
        }
    }
}

Node NodeManager::GetNode(NodeID n) {
    auto found = node_.find(n);
    if(found!=node_.end())
        return found->second;
    else
        return Node();
}

ServerID NodeManager::FindServer(NodeID n) {
    if(replication_scheme_ == Config::ReplicationScheme::NO_REPLICATION) {
        return (ServerID)n;
    }
    else {
         auto found = node2server_.find(n);
         if(found!=node2server_.end())
             return found->second;
         else
             return (ServerID)-1;
    }
}

void NodeManager::Print() {
    std::cout << "NodeManager " << std::endl;
    std::cout << "- Nodes" << std::endl;
    for(auto &node:node_) {
        std::cout << " - Node " << node.first << ": " << node.second << std::endl;
    }
    std::cout << "- Node -> Server " << std::endl;
    for(auto node:node2server_) {
        std::cout << " - Node " << node.first << " -> " << node.second << std::endl;
    }
    std::cout << "- Server -> Node " << std::endl;
    for(auto server:server2node_) {
        std::cout << " - Server " << server.first << " -> [ ";
        for(auto node:server.second) {
            std::cout << node << " ";
        }
        std::cout << "]" << std::endl;
    }
}

} // namespace radixtree
