/*
 *  (c) Copyright 2016-2017 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <gtest/gtest.h>
#include <boost/filesystem.hpp>
#include <random>

#include "radixtree/radixtree_libpmem.h"
#include "radixtree/radixtree_fam_atomic.h"
#include "radixtree/kvs.h"

#include "nvmm/memory_manager.h"
#include "nvmm/epoch_manager.h"

using namespace radixtree;
using namespace nvmm;

std::random_device r;
std::default_random_engine e1(r());
uint64_t rand_uint64(uint64_t min, uint64_t max)
{
    std::uniform_int_distribution<uint64_t> uniform_dist(min, max);
    return uniform_dist(e1);
}

std::string rand_string(size_t min_len, size_t max_len)
{
    static char const dict[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

    size_t len = (size_t)rand_uint64(min_len, max_len);
    std::string ret(len, '\0');
    for (size_t i = 0; i < len; i++)
    {
        ret[i]=dict[rand_uint64(0,sizeof(dict)-2)];
    }

    return ret;
}

inline void ResetBuf(char *buf, size_t &len, size_t const max_len) {
    memset(buf, 0, max_len);
    len=max_len;
}

TEST(KeyValueStore, SingleProcess) {
    KeyValueStore *kvs;

    // create a new radix tree
    kvs = KeyValueStore::MakeKVS(0, 0);
    EXPECT_NE(nullptr, kvs);
    GlobalPtr root = kvs->Location();
    delete kvs;

    // open an existing radix tree
    kvs = KeyValueStore::MakeKVS(0, root);
    EXPECT_NE(nullptr, kvs);

    // test put, get, del
    size_t const max_val_len = 1024;
    EXPECT_GE(kvs->MaxValLen(), max_val_len);
    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(val_buf, val_len, max_val_len);

    std::string key, val;
    int ret;

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(-1, ret);
    ResetBuf(val_buf, val_len, max_val_len);

    // del 1
    key = "1";
    ret = kvs->Del(key.c_str(), key.size());
    EXPECT_EQ(-1, ret);

    // put 1:a
    key = "1";
    val = "a";
    ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
    EXPECT_EQ(0, ret);

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(val, std::string(val_buf, val_len));
    ResetBuf(val_buf, val_len, max_val_len);

    // put 1:b
    key = "1";
    val = "b";
    ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
    EXPECT_EQ(0, ret);

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(val, std::string(val_buf, val_len));
    ResetBuf(val_buf, val_len, max_val_len);

    // del 1
    key = "1";
    ret = kvs->Del(key.c_str(), key.size());
    EXPECT_EQ(0, ret);

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(-1, ret);
    ResetBuf(val_buf, val_len, max_val_len);

    delete kvs;
}

// multi-process
static int const process_count = 16;
static int const loop_count = 5000;

void DoWork(GlobalPtr root)
{
    // =======================================================================
    // reset epoch manager after fork()
    EpochManager *em = EpochManager::GetInstance();
    em->ResetAfterFork();

    // =======================================================================
    // open an existing radix tree
    KeyValueStore *kvs = KeyValueStore::MakeKVS(0, root);
    EXPECT_NE(nullptr, kvs);

    // =======================================================================
    // stress test
    pid_t pid = getpid();

    std::string key, val;
    size_t const max_key_len = kvs->MaxKeyLen();

    size_t const max_val_len = 40;
    EXPECT_GE(kvs->MaxValLen(), max_val_len);
    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(val_buf, val_len, max_val_len);

    for (int i=0; i<loop_count; i++)
    {
        key = rand_string(1, max_key_len);
        val = rand_string(0, max_val_len);

        int op=(i+pid)%3;
        if (op==0)
        {
            (void)kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
        }
        else if (op==1)
        {
            (void)kvs->Get(key.c_str(), key.size(), val_buf, val_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        else
        {
            (void)kvs->Del(key.c_str(), key.size());
        }
    }
    std::cout << pid << " DONE" << std::endl;

    delete kvs;
}

TEST(KeyValueStore, MultiProcessStress) {
    // =======================================================================
    // create a new radix tree
    KeyValueStore *kvs = KeyValueStore::MakeKVS(0, 0);
    EXPECT_NE(nullptr, kvs);
    GlobalPtr root = kvs->Location();
    delete kvs;

    // =======================================================================
    // reset epoch manager before fork()
    EpochManager *em = EpochManager::GetInstance();
    em->ResetBeforeFork();

    // =======================================================================
    // do work
    pid_t pid[process_count];

    for (int i=0; i< process_count; i++)
    {
        pid[i] = fork();
        ASSERT_LE(0, pid[i]);
        if (pid[i]==0)
        {
            // child
            DoWork(root);
            exit(0); // this will leak memory (see valgrind output)
        }
        else
        {
            // parent
            continue;
        }
    }

    for (int i=0; i< process_count; i++)
    {
        int status;
        waitpid(pid[i], &status, 0);
    }

    // =======================================================================
    // reset epoch manager after fork() for the main process
    em->ResetAfterFork();
}


void Init()
{
    KeyValueStore::Reset();
    KeyValueStore::Start();
}

int main (int argc, char** argv) {
    Init();
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
