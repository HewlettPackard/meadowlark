/*
 *  (c) Copyright 2016-2017 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <gtest/gtest.h>
#include <boost/filesystem.hpp>
#include <random>

#include "radixtree/radixtree_libpmem.h"
#include "radixtree/radixtree_fam_atomic.h"
#include "radixtree/kvs.h"

#include "nvmm/memory_manager.h"
#include "nvmm/epoch_manager.h"

using namespace radixtree;
using namespace nvmm;

std::random_device r;
std::default_random_engine e1(r());
uint64_t rand_uint64(uint64_t min, uint64_t max)
{
    std::uniform_int_distribution<uint64_t> uniform_dist(min, max);
    return uniform_dist(e1);
}

std::string rand_string(size_t min_len, size_t max_len)
{
    static char const dict[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

    size_t len = (size_t)rand_uint64(min_len, max_len);
    std::string ret(len, '\0');
    for (size_t i = 0; i < len; i++)
    {
        ret[i]=dict[rand_uint64(0,sizeof(dict)-2)];
    }

    return ret;
}

// endianness conversion for uint64_t
inline uint64_t convert(uint64_t num) {
#ifdef SYS_LITTLE_ENDIAN
    num = __builtin_bswap64(num);
#endif
    return num;
}

inline void ResetBuf(char *buf, size_t &len, size_t const max_len) {
    memset(buf, 0, max_len);
    len=max_len;
}

TEST(KeyValueStore, SingleProcess) {
    KeyValueStore *kvs;

    // create a new radix tree
    kvs = KeyValueStore::MakeKVS(0, 0);
    EXPECT_NE(nullptr, kvs);
    GlobalPtr root = kvs->Location();
    delete kvs;

    // open an existing radix tree
    kvs = KeyValueStore::MakeKVS(0, root);
    EXPECT_NE(nullptr, kvs);

    // test put, get, del
    size_t const max_val_len = 1024;
    EXPECT_GE(kvs->MaxValLen(), max_val_len);
    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(val_buf, val_len, max_val_len);

    std::string key, val;
    int ret;

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(-1, ret);
    ResetBuf(val_buf, val_len, max_val_len);

    // del 1
    key = "1";
    ret = kvs->Del(key.c_str(), key.size());
    EXPECT_EQ(-1, ret);

    // put 1:a
    key = "1";
    val = "a";
    ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
    EXPECT_EQ(0, ret);

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(val, std::string(val_buf, val_len));
    ResetBuf(val_buf, val_len, max_val_len);

    // put 1:b
    key = "1";
    val = "b";
    ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
    EXPECT_EQ(0, ret);

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(val, std::string(val_buf, val_len));
    ResetBuf(val_buf, val_len, max_val_len);

    // del 1
    key = "1";
    ret = kvs->Del(key.c_str(), key.size());
    EXPECT_EQ(0, ret);

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(-1, ret);
    ResetBuf(val_buf, val_len, max_val_len);

    delete kvs;
}

TEST(KeyValueStore, SingleProcessScan) {
    KeyValueStore *kvs;

    // create a new radix tree
    kvs = KeyValueStore::MakeKVS(0, 0);
    EXPECT_NE(nullptr, kvs);

    size_t const max_val_len = 40;
    size_t const max_key_len = kvs->MaxKeyLen();

    // insert
    {
        std::string key, val;
        int ret;

        key = std::string(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        val = "OPEN";
        ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
        EXPECT_EQ(0, ret);

        for(uint64_t i=5; i<500; i++) {
            uint64_t num = convert(i);
            key = std::string((char*)&num, sizeof(num));
            val = std::to_string(i);
            ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
            EXPECT_EQ(0, ret);
        }
    }

    // scan [0, 5]
    {
        uint64_t begin_key_num = 0;
        uint64_t end_key_num = 5;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);

        uint64_t key = convert(end_key_num);
        EXPECT_EQ(key, *((uint64_t*)key_buf));
        std::string val = std::to_string(end_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // scan (0, 5]
    {
        uint64_t begin_key_num = 0;
        uint64_t end_key_num = 5;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);

        uint64_t key = convert(end_key_num);
        EXPECT_EQ(key, *((uint64_t*)key_buf));
        std::string val = std::to_string(end_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // scan [0, 5)
    {
        uint64_t begin_key_num = 0;
        uint64_t end_key_num = 5;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-1, ret);
    }

    // scan (0, 5)
    {
        uint64_t begin_key_num = 0;
        uint64_t end_key_num = 5;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-1, ret);
    }

    // scan [499, 600]
    {
        uint64_t begin_key_num = 499;
        uint64_t end_key_num = 600;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);

        uint64_t key = convert(begin_key_num);
        EXPECT_EQ(key, *((uint64_t*)key_buf));
        std::string val = std::to_string(begin_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // scan (499, 600]
    {
        uint64_t begin_key_num = 499;
        uint64_t end_key_num = 600;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(-1, ret);
    }

    // scan [499, 600)
    {
        uint64_t begin_key_num = 499;
        uint64_t end_key_num = 600;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);

        uint64_t key = convert(begin_key_num);
        EXPECT_EQ(key, *((uint64_t*)key_buf));
        std::string val = std::to_string(begin_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // scan (499, 600)
    {
        uint64_t begin_key_num = 499;
        uint64_t end_key_num = 600;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-1, ret);
    }

    // scan [10, 10]
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 10;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);

        uint64_t key = convert(begin_key_num);
        EXPECT_EQ(key, *((uint64_t*)key_buf));
        std::string val = std::to_string(begin_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // scan (10, 10]
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 10;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(-1, ret);
    }

    // scan [10, 10)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 10;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-1, ret);
    }

    // scan (10, 10)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 10;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-1, ret);
    }

    // scan [10, 100]
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 100;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
        EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        i++;
        for(; i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // scan [10, 100)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 100;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
        EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        i++;
        for(; i<=end_key_num-1;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // scan (10, 100]
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 100;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num+1;
        EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
        EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        i++;
        for(; i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // scan (10, 100)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 100;
        uint64_t begin_key_buf = convert(begin_key_num);
        uint64_t end_key_buf = convert(end_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num+1;
        EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
        EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        i++;
        for(; i<=end_key_num-1;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan [-inf, +inf] => not valid open boundaries  => scan ['\0','\0'] => '\0'
    {
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        std::string val = "OPEN";
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan [-inf, +inf) => valid open boundary for end key => scan ['\0',+inf)
    {
        uint64_t begin_key_num = 5;
        uint64_t end_key_num = 499;
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        std::string val = "OPEN";
        EXPECT_EQ(val, std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        uint64_t i=begin_key_num;
        for(;i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (-inf, +inf] => valid open boundary for begin key => scan (-inf, '\0']
    {
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        std::string val = "OPEN";
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (-inf, +inf)
    {
        uint64_t begin_key_num = 5;
        uint64_t end_key_num = 499;
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        std::string val = "OPEN";
        EXPECT_EQ(val, std::string(val_buf, val_len));

        uint64_t i=begin_key_num;
        for(;i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (-inf, 100]
    {
        uint64_t begin_key_num = 5;
        uint64_t end_key_num = 100;
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        uint64_t end_key_buf = convert(end_key_num);
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        std::string val = "OPEN";
        EXPECT_EQ(val, std::string(val_buf, val_len));

        uint64_t i=begin_key_num;
        for(;i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan [10, +inf)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 499;
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        uint64_t begin_key_buf = convert(begin_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
        EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        i++;
        for(;i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (-inf, 100)
    {
        uint64_t begin_key_num = 5;
        uint64_t end_key_num = 100;
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        uint64_t end_key_buf = convert(end_key_num);
        std::string end_key((char*)&end_key_buf, sizeof(end_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        std::string val = "OPEN";
        EXPECT_EQ(val, std::string(val_buf, val_len));

        uint64_t i=begin_key_num;
        for(;i<=end_key_num-1;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (10, +inf)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 499;
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        uint64_t begin_key_buf = convert(begin_key_num);
        std::string begin_key((char*)&begin_key_buf, sizeof(begin_key_buf));

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num+1;
        EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
        EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        i++;
        for(;i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)key_buf)));
            EXPECT_EQ(std::to_string(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-1, ret);
    }

    // delete the radix tree
    delete kvs;
}


// multi-process
static int const process_count = 16;
static int const loop_count = 5000;

void DoWork(GlobalPtr root)
{
    // =======================================================================
    // reset epoch manager after fork()
    EpochManager *em = EpochManager::GetInstance();
    em->ResetAfterFork();

    // =======================================================================
    // open an existing radix tree
    KeyValueStore *kvs = KeyValueStore::MakeKVS(0, root);
    EXPECT_NE(nullptr, kvs);

    // =======================================================================
    // stress test
    pid_t pid = getpid();

    std::string key, val;
    size_t const max_key_len = kvs->MaxKeyLen();
    char key_buf[max_key_len];
    size_t key_len;
    ResetBuf(key_buf, key_len, max_key_len);

    size_t const max_val_len = 40;
    EXPECT_GE(kvs->MaxValLen(), max_val_len);
    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(val_buf, val_len, max_val_len);

    for (int i=0; i<loop_count; i++)
    {
        int op=(int)rand_uint64(0,3);
        if (op==0)
        {
            key = rand_string(1, max_key_len);
            val = rand_string(0, max_val_len);
            (void)kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
        }
        else if (op==1)
        {
            key = rand_string(1, max_key_len);
            (void)kvs->Get(key.c_str(), key.size(), val_buf, val_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        else if (op==2)
        {
            key = rand_string(1, max_key_len);
            (void)kvs->Del(key.c_str(), key.size());
        }
        else
        {
            std::string begin_key = rand_string(1, max_key_len);
            std::string end_key = rand_string(1, max_key_len);
            int iter;
            int ret = kvs->Scan(iter,
                                key_buf, key_len,
                                val_buf, val_len,
                                begin_key.c_str(), begin_key.size(), true,
                                end_key.c_str(), end_key.size(), true);
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
            int cnt = (int)rand_uint64(0,100);
            for(int i=0; ret==0 && i<cnt; i++) {
                ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
                ResetBuf(key_buf, key_len, max_key_len);
                ResetBuf(val_buf, val_len, max_val_len);
            }
        }
    }
    std::cout << pid << " DONE" << std::endl;

    delete kvs;
}

TEST(KeyValueStore, MultiProcessStress) {
    // =======================================================================
    // create a new radix tree
    KeyValueStore *kvs = KeyValueStore::MakeKVS(0, 0);
    EXPECT_NE(nullptr, kvs);
    GlobalPtr root = kvs->Location();
    delete kvs;

    // =======================================================================
    // reset epoch manager before fork()
    EpochManager *em = EpochManager::GetInstance();
    em->ResetBeforeFork();

    // =======================================================================
    // do work
    pid_t pid[process_count];

    for (int i=0; i< process_count; i++)
    {
        pid[i] = fork();
        ASSERT_LE(0, pid[i]);
        if (pid[i]==0)
        {
            // child
            DoWork(root);
            exit(0); // this will leak memory (see valgrind output)
        }
        else
        {
            // parent
            continue;
        }
    }

    for (int i=0; i< process_count; i++)
    {
        int status;
        waitpid(pid[i], &status, 0);
    }

    // =======================================================================
    // reset epoch manager after fork() for the main process
    em->ResetAfterFork();
}


void Init()
{
    KeyValueStore::Reset();
    KeyValueStore::Start();
}

int main (int argc, char** argv) {
    Init();
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
