/*
 *  (c) Copyright 2016-2021 Hewlett Packard Enterprise Development Company LP.
 *
 *  This software is available to you under a choice of one of two
 *  licenses. You may choose to be licensed under the terms of the
 *  GNU Lesser General Public License Version 3, or (at your option)
 *  later with exceptions included below, or under the terms of the
 *  MIT license (Expat) available in COPYING file in the source tree.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <gtest/gtest.h>
#include <random>
#include <limits>

#include "radixtree/kvs.h"

#include "nvmm/memory_manager.h"
#include "nvmm/epoch_manager.h"
#include "nvmm/fam.h"

using namespace radixtree;
using namespace nvmm;


//KeyValueStore::IndexType const KVSTYPE = KeyValueStore::RADIX_TREE_TINY;
KeyValueStore::IndexType const KVSTYPE = KeyValueStore::RADIX_TREE;

std::random_device r;
std::default_random_engine e1(r());
uint64_t rand_uint64(uint64_t min, uint64_t max)
{
    std::uniform_int_distribution<uint64_t> uniform_dist(min, max);
    return uniform_dist(e1);
}

std::string rand_string(size_t min_len, size_t max_len)
{
    static char const dict[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

    size_t len = (size_t)rand_uint64(min_len, max_len);
    std::string ret(len, '\0');
    for (size_t i = 0; i < len; i++)
    {
        ret[i]=dict[rand_uint64(0,sizeof(dict)-2)];
    }

    return ret;
}

// endianness conversion for uint64_t
inline uint64_t convert(uint64_t num) {
#ifdef SYS_LITTLE_ENDIAN
    num = __builtin_bswap64(num);
#endif
    return num;
}

inline std::string num2str(uint64_t num) {
#ifdef SYS_LITTLE_ENDIAN
    num = __builtin_bswap64(num);
#endif
    return std::string((char*)&num, sizeof(num));
}


inline void ResetBuf(char *buf, size_t &len, size_t const max_len) {
    memset(buf, 0, max_len);
    len=max_len;
}

TEST(KeyValueStore, SingleProcess) {
    KeyValueStore *kvs;

    // create a new radix tree
    kvs = KeyValueStore::MakeKVS(KVSTYPE, 0);
    EXPECT_NE(nullptr, kvs);
    GlobalPtr root = kvs->Location();
    delete kvs;

    // open an existing radix tree
    kvs = KeyValueStore::MakeKVS(KVSTYPE, root);
    EXPECT_NE(nullptr, kvs);


    // test put, get, del
    size_t const min_val_len = kvs->MaxValLen()<1024?kvs->MaxValLen():0;
    size_t const max_val_len = kvs->MaxValLen()<1024?kvs->MaxValLen():1024;
    EXPECT_GE(kvs->MaxValLen(), max_val_len);
    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(val_buf, val_len, max_val_len);

    std::string key, val;
    int ret;

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(-2, ret);
    ResetBuf(val_buf, val_len, max_val_len);

    // del 1
    key = "1";
    ret = kvs->Del(key.c_str(), key.size());
    EXPECT_EQ(-2, ret);

    // put 1
    key = "1";
    val = rand_string(min_val_len, max_val_len);
    ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
    EXPECT_EQ(0, ret);

    // Find or Create 1.
    key = "1";
    ret = kvs->FindOrCreate(key.c_str(), key.size(), val.c_str(), val.size(), val_buf, val_len);
    EXPECT_EQ(-3, ret);

    // Find or Create 2.
    key = "2";
    ret = kvs->FindOrCreate(key.c_str(), key.size(), val.c_str(), val.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);

    // Delete 2
    key = "2";
    ret = kvs->Del(key.c_str(), key.size());
    EXPECT_EQ(0, ret);

    // Find or Create 2 Again
    key = "2";
    ret = kvs->FindOrCreate(key.c_str(), key.size(), val.c_str(), val.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);

    // Get 2
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(val, std::string(val_buf, val_len));

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(val, std::string(val_buf, val_len));
    ResetBuf(val_buf, val_len, max_val_len);

    /* FindOrCreate further test cases to trigger split */
    key = "30";
    ret = kvs->FindOrCreate(key.c_str(), key.size(), val.c_str(), val.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);

    key = "31";
    ret = kvs->FindOrCreate(key.c_str(), key.size(), val.c_str(), val.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);

    key = "32";
    ret = kvs->FindOrCreate(key.c_str(), key.size(), val.c_str(), val.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);

    key = "3";
    ret = kvs->FindOrCreate(key.c_str(), key.size(), val.c_str(), val.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);

    /* Should return the found value */
    key = "3";
    ret = kvs->FindOrCreate(key.c_str(), key.size(), val.c_str(), val.size(), val_buf, val_len);
    EXPECT_EQ(-3, ret);

    key = "32";
    ret = kvs->FindOrCreate(key.c_str(), key.size(), val.c_str(), val.size(), val_buf, val_len);
    EXPECT_EQ(-3, ret);

    // put 1
    key = "1";
    val = rand_string(min_val_len, max_val_len);
    ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
    EXPECT_EQ(0, ret);
    ResetBuf(val_buf, val_len, max_val_len);

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(val, std::string(val_buf, val_len));
    ResetBuf(val_buf, val_len, max_val_len);

    // del 1
    key = "1";
    ret = kvs->Del(key.c_str(), key.size());
    EXPECT_EQ(0, ret);

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len);
    EXPECT_EQ(-2, ret);
    ResetBuf(val_buf, val_len, max_val_len);

    delete kvs;
}

TEST(KeyValueStore, SingleProcessCachingAPI) {
    KeyValueStore *kvs;

    // create a new radix tree
    kvs = KeyValueStore::MakeKVS(KVSTYPE, 0);
    EXPECT_NE(nullptr, kvs);
    GlobalPtr root = kvs->Location();
    delete kvs;

    // open an existing radix tree
    kvs = KeyValueStore::MakeKVS(KVSTYPE, root);
    EXPECT_NE(nullptr, kvs);

    // test put, get, del
    size_t const min_val_len = kvs->MaxValLen()<1024?kvs->MaxValLen():0;
    size_t const max_val_len = kvs->MaxValLen()<1024?kvs->MaxValLen():1024;
    EXPECT_GE(kvs->MaxValLen(), max_val_len);
    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(val_buf, val_len, max_val_len);

    std::string key, val;
    int ret;
    Gptr key_ptr, old_key_ptr;
    TagGptr val_ptr, old_val_ptr;

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len, key_ptr, val_ptr);
    EXPECT_EQ(0, ret);
    EXPECT_FALSE(key_ptr.IsValid());
    ResetBuf(val_buf, val_len, max_val_len);

    // del 1
    key = "1";
    ret = kvs->Del(key.c_str(), key.size(), key_ptr, val_ptr);
    EXPECT_EQ(0, ret);
    EXPECT_FALSE(key_ptr.IsValid());

    // put 1
    key = "1";
    val = rand_string(min_val_len, max_val_len);
    ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
    EXPECT_EQ(0, ret);

    // get 1
    key = "1";
    ret = kvs->Get(key.c_str(), key.size(), val_buf, val_len, key_ptr, val_ptr);
    EXPECT_EQ(0, ret);
    EXPECT_TRUE(key_ptr.IsValid());
    EXPECT_TRUE(val_ptr.IsValid());
    EXPECT_EQ(val, std::string(val_buf, val_len));
    ResetBuf(val_buf, val_len, max_val_len);

    // get 1
    // val_ptr is up-to-date
    old_val_ptr=val_ptr;
    key = "1";
    ret = kvs->Get(key_ptr, val_ptr, val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(old_val_ptr, val_ptr);
    ResetBuf(val_buf, val_len, max_val_len);

    // put 1
    old_key_ptr=key_ptr;
    old_val_ptr=val_ptr;
    key = "1";
    val = rand_string(min_val_len, max_val_len);
    ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size(), key_ptr, val_ptr);
    EXPECT_EQ(0, ret);
    EXPECT_TRUE(key_ptr.IsValid());
    EXPECT_TRUE(val_ptr.IsValid());
    EXPECT_EQ(old_key_ptr, key_ptr);
    EXPECT_EQ(old_val_ptr.tag()+1, val_ptr.tag());

    // put 1
    old_key_ptr=key_ptr;
    old_val_ptr=val_ptr;
    key = "1";
    val = rand_string(min_val_len, max_val_len);
    ret = kvs->Put(key_ptr, val_ptr, val.c_str(), val.size());
    EXPECT_EQ(0, ret);
    EXPECT_TRUE(key_ptr.IsValid());
    EXPECT_TRUE(val_ptr.IsValid());
    EXPECT_EQ(old_key_ptr, key_ptr);
    EXPECT_EQ(old_val_ptr.tag()+1, val_ptr.tag());

    // get 1
    // val_ptr is up-to-date
    // old_val_ptr is not up-to-date
    EXPECT_EQ(old_val_ptr.tag()+1, val_ptr.tag());
    key = "1";
    ret = kvs->Get(key_ptr, old_val_ptr, val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(val, std::string(val_buf, val_len));
    EXPECT_EQ(old_val_ptr, val_ptr);
    ResetBuf(val_buf, val_len, max_val_len);


    // del 1:c
    old_key_ptr=key_ptr;
    old_val_ptr=val_ptr;
    key = "1";
    ret = kvs->Del(key.c_str(), key.size(), key_ptr, val_ptr);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(old_key_ptr, key_ptr);
    EXPECT_EQ(old_val_ptr.tag()+1, val_ptr.tag());
    EXPECT_FALSE(val_ptr.gptr().IsValid());

    // del 1 again
    old_key_ptr=key_ptr;
    old_val_ptr=val_ptr;
    ret = kvs->Del(key_ptr, val_ptr);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(old_key_ptr, key_ptr);
    EXPECT_EQ(old_val_ptr.tag()+1, val_ptr.tag());
    EXPECT_FALSE(val_ptr.gptr().IsValid());

    // get 1
    old_key_ptr=key_ptr;
    old_val_ptr=val_ptr;
    ret = kvs->Get(key_ptr, val_ptr, val_buf, val_len);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(old_key_ptr, key_ptr);
    EXPECT_EQ(old_val_ptr, val_ptr);
    ResetBuf(val_buf, val_len, max_val_len);

    delete kvs;
}

TEST(KeyValueStore, SingleProcessScan) {
    KeyValueStore *kvs;

    // create a new radix tree
    kvs = KeyValueStore::MakeKVS(KVSTYPE, 0);
    EXPECT_NE(nullptr, kvs);

    size_t const max_val_len = kvs->MaxValLen()<1024?kvs->MaxValLen():1024;
    size_t const max_key_len = kvs->MaxKeyLen();

    uint64_t const OPEN = 12345;

    // insert
    {
        std::string key, val;
        int ret;

        key = std::string(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        val = num2str(OPEN);
        ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
        EXPECT_EQ(0, ret);

        for(uint64_t i=5; i<500; i++) {
            key = num2str(i);
            val = num2str(i);
            ret = kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
            EXPECT_EQ(0, ret);
        }
    }

    // scan [0, 5]
    {
        uint64_t begin_key_num = 0;
        uint64_t end_key_num = 5;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);

        std::string key = num2str(end_key_num);
        EXPECT_EQ(key, std::string(key_buf, key_len));
        std::string val = num2str(end_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // scan (0, 5]
    {
        uint64_t begin_key_num = 0;
        uint64_t end_key_num = 5;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);

        std::string key = num2str(end_key_num);
        EXPECT_EQ(key, std::string(key_buf, key_len));
        std::string val = num2str(end_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // scan [0, 5)
    {
        uint64_t begin_key_num = 0;
        uint64_t end_key_num = 5;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-2, ret);
    }

    // scan (0, 5)
    {
        uint64_t begin_key_num = 0;
        uint64_t end_key_num = 5;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-2, ret);
    }

    // scan [499, 600]
    {
        uint64_t begin_key_num = 499;
        uint64_t end_key_num = 600;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);

        std::string key = num2str(begin_key_num);
        EXPECT_EQ(key, std::string(key_buf, key_len));
        std::string val = num2str(begin_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // scan (499, 600]
    {
        uint64_t begin_key_num = 499;
        uint64_t end_key_num = 600;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(-2, ret);
    }

    // scan [499, 600)
    {
        uint64_t begin_key_num = 499;
        uint64_t end_key_num = 600;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);

        std::string key = num2str(begin_key_num);
        EXPECT_EQ(key, std::string(key_buf, key_len));
        std::string val = num2str(begin_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // scan (499, 600)
    {
        uint64_t begin_key_num = 499;
        uint64_t end_key_num = 600;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-2, ret);
    }

    // scan [10, 10]
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 10;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);

        std::string key = num2str(begin_key_num);
        EXPECT_EQ(key, std::string(key_buf, key_len));
        std::string val = num2str(begin_key_num);
        EXPECT_EQ(val, std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // scan (10, 10]
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 10;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(-2, ret);
    }

    // scan [10, 10)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 10;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-2, ret);
    }

    // scan (10, 10)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 10;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(-2, ret);
    }

    // scan [10, 100]
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 100;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        std::string key = num2str(begin_key_num);
        EXPECT_EQ(key, std::string(key_buf, key_len));
        uint64_t i=begin_key_num;
        EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
        EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        i++;
        for(; i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // scan [10, 100)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 100;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
        EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        i++;
        for(; i<=end_key_num-1;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // scan (10, 100]
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 100;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num+1;
        EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
        EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        i++;
        for(; i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // scan (10, 100)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 100;
        std::string begin_key=num2str(begin_key_num);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num+1;
        EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
        EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        i++;
        for(; i<=end_key_num-1;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // with open boundary
    // scan [-inf, +inf] => not valid open boundaries  => scan ['\0','\0'] => '\0'
    {
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        EXPECT_EQ(num2str(OPEN), std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // with open boundary
    // scan [-inf, +inf) => valid open boundary for end key => scan ['\0',+inf)
    {
        uint64_t begin_key_num = 5;
        uint64_t end_key_num = 499;
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        EXPECT_EQ(num2str(OPEN), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);

        uint64_t i=begin_key_num;
        for(;i<=end_key_num;i++) {
            std::cout << i << std::endl;
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // with open boundary
    // scan (-inf, +inf] => valid open boundary for begin key => scan (-inf, '\0']
    {
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        EXPECT_EQ(num2str(OPEN), std::string(val_buf, val_len));

        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // with open boundary
    // scan (-inf, +inf)
    {
        uint64_t begin_key_num = 5;
        uint64_t end_key_num = 499;
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        EXPECT_EQ(num2str(OPEN), std::string(val_buf, val_len));

        uint64_t i=begin_key_num;
        for(;i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // with open boundary
    // scan (-inf, 100]
    {
        uint64_t begin_key_num = 5;
        uint64_t end_key_num = 100;
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), true);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        EXPECT_EQ(num2str(OPEN), std::string(val_buf, val_len));

        uint64_t i=begin_key_num;
        for(;i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // with open boundary
    // scan [10, +inf)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 499;
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string begin_key=num2str(begin_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), true,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
        EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        i++;
        for(;i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // with open boundary
    // scan (-inf, 100)
    {
        uint64_t begin_key_num = 5;
        uint64_t end_key_num = 100;
        std::string begin_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string end_key=num2str(end_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        EXPECT_EQ(begin_key, std::string(key_buf, key_len));
        EXPECT_EQ(num2str(OPEN), std::string(val_buf, val_len));

        uint64_t i=begin_key_num;
        for(;i<=end_key_num-1;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // with open boundary
    // scan (10, +inf)
    {
        uint64_t begin_key_num = 10;
        uint64_t end_key_num = 499;
        std::string end_key(KeyValueStore::OPEN_BOUNDARY_KEY, KeyValueStore::OPEN_BOUNDARY_KEY_SIZE);
        std::string begin_key=num2str(begin_key_num);

        char key_buf[max_key_len];
        size_t key_len;
        ResetBuf(key_buf, key_len, max_key_len);
        char val_buf[max_val_len];
        size_t val_len;
        ResetBuf(val_buf, val_len, max_val_len);

        int iter;
        int ret = kvs->Scan(iter,
                            key_buf, key_len,
                            val_buf, val_len,
                            begin_key.c_str(), begin_key.size(), false,
                            end_key.c_str(), end_key.size(), false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num+1;
        EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
        EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
        ResetBuf(key_buf, key_len, max_key_len);
        ResetBuf(val_buf, val_len, max_val_len);
        i++;
        for(;i<=end_key_num;i++) {
            ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(num2str(i), std::string(key_buf, key_len));
            EXPECT_EQ(num2str(i), std::string(val_buf, val_len));
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
        EXPECT_EQ(-2, ret);
    }

    // delete the radix tree
    delete kvs;
}


// multi-process
static int const process_count = 16;
static int const loop_count = 5000;

void DoWork(GlobalPtr root)
{
    // =======================================================================
    // reset epoch manager after fork()
    EpochManager *em = EpochManager::GetInstance();
    em->Start();

    // =======================================================================
    // open an existing radix tree
    KeyValueStore *kvs = KeyValueStore::MakeKVS(KVSTYPE, root);
    EXPECT_NE(nullptr, kvs);

    // =======================================================================
    // stress test
    pid_t pid = getpid();

    std::string key, val;
    size_t const max_key_len = kvs->MaxKeyLen();
    char key_buf[max_key_len];
    size_t key_len;
    ResetBuf(key_buf, key_len, max_key_len);

    size_t const min_val_len = kvs->MaxValLen()<1024?kvs->MaxValLen():0;
    size_t const max_val_len = kvs->MaxValLen()<1024?kvs->MaxValLen():1024;
    EXPECT_GE(kvs->MaxValLen(), max_val_len);
    char val_buf[max_val_len];
    size_t val_len;
    ResetBuf(val_buf, val_len, max_val_len);

    for (int i=0; i<loop_count; i++)
    {
        int op=(int)rand_uint64(0,3);
        if (op==0)
        {
            key = rand_string(1, max_key_len);
            val = rand_string(min_val_len, max_val_len);
            (void)kvs->Put(key.c_str(), key.size(), val.c_str(), val.size());
        }
        else if (op==1)
        {
            key = rand_string(1, max_key_len);
            (void)kvs->Get(key.c_str(), key.size(), val_buf, val_len);
            ResetBuf(val_buf, val_len, max_val_len);
        }
        else if (op==2)
        {
            key = rand_string(1, max_key_len);
            (void)kvs->Del(key.c_str(), key.size());
        }
        else
        {
            std::string begin_key = rand_string(1, max_key_len);
            std::string end_key = rand_string(1, max_key_len);
            int iter;
            int ret = kvs->Scan(iter,
                                key_buf, key_len,
                                val_buf, val_len,
                                begin_key.c_str(), begin_key.size(), true,
                                end_key.c_str(), end_key.size(), true);
            ResetBuf(key_buf, key_len, max_key_len);
            ResetBuf(val_buf, val_len, max_val_len);
            int cnt = (int)rand_uint64(0,100);
            for(int i=0; ret==0 && i<cnt; i++) {
                ret = kvs->GetNext(iter, key_buf, key_len, val_buf, val_len);
                ResetBuf(key_buf, key_len, max_key_len);
                ResetBuf(val_buf, val_len, max_val_len);
            }
        }
    }
    std::cout << pid << " DONE" << std::endl;

    delete kvs;
}

TEST(KeyValueStore, MultiProcessStress) {
    // =======================================================================
    // create a new radix tree
    KeyValueStore *kvs = KeyValueStore::MakeKVS(KVSTYPE, 0);
    EXPECT_NE(nullptr, kvs);
    GlobalPtr root = kvs->Location();
    delete kvs;

    // =======================================================================
    // reset epoch manager before fork()
    EpochManager *em = EpochManager::GetInstance();
    em->Stop();

    // =======================================================================
    // do work
    pid_t pid[process_count];

    for (int i=0; i< process_count; i++)
    {
        pid[i] = fork();
        ASSERT_LE(0, pid[i]);
        if (pid[i]==0)
        {
            // child
            DoWork(root);
            exit(0); // this will leak memory (see valgrind output)
        }
        else
        {
            // parent
            continue;
        }
    }

    for (int i=0; i< process_count; i++)
    {
        int status;
        waitpid(pid[i], &status, 0);
    }

    // =======================================================================
    // reset epoch manager after fork() for the main process
    em->Start();
}

void Init()
{
    nvmm::ResetNVMM();
    nvmm::StartNVMM();
}

int main (int argc, char** argv) {
    Init();
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
