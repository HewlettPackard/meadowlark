/*
 *  (c) Copyright 2016-2017 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <gtest/gtest.h>
#include <boost/filesystem.hpp>
#include <random>

#include "radixtree/radixtree_libpmem.h"
#include "radixtree/radixtree_fam_atomic.h"
#include "radixtree/radix_tree.h"

#include "nvmm/memory_manager.h"
#include "nvmm/heap.h"
#include "nvmm/root_shelf.h"

using namespace radixtree;
using namespace nvmm;

std::random_device r;
std::default_random_engine e1(r());
uint64_t rand_uint64(uint64_t min, uint64_t max)
{
    std::uniform_int_distribution<uint64_t> uniform_dist(min, max);
    return uniform_dist(e1);
}

std::string rand_string(size_t min_len, size_t max_len)
{
    static char const dict[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

    size_t len = (size_t)rand_uint64(min_len, max_len);
    std::string ret(len, '\0');
    for (size_t i = 0; i < len; i++)
    {
        ret[i]=dict[rand_uint64(0,sizeof(dict)-2)];
    }

    return ret;
}

TEST(RadixTree, SingleProcess) {
    PoolId const heap_id = 1; // assuming we only use heap id 1
    size_t const heap_size = 1024*1024*1024; // 1024MB

    // init memory manager and heap
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = nullptr;
    EXPECT_EQ(NO_ERROR, mm->CreateHeap(heap_id, heap_size));
    EXPECT_EQ(NO_ERROR, mm->FindHeap(heap_id, &heap));
    EXPECT_NE(nullptr, heap);

    // open the heap
    EXPECT_EQ(NO_ERROR, heap->Open());

    // init the radix tree
    RadixTree *tree = nullptr;
    GlobalPtr root;
    // create a new radix tree
    tree = new RadixTree(mm, heap);
    root = tree->get_root();
    EXPECT_NE(nullptr, tree);
    delete tree;

    // open an existing radix tree
    tree = new RadixTree(mm, heap, root);
    EXPECT_NE(nullptr, tree);

    // test put, get, destroy
    bool success;
    RadixTree::key_type key_buf;
    int key_size;
    memset(&key_buf, 0, sizeof(key_buf));
    uint64_t key, value;
    uint64_t *value_ptr;
    GlobalPtr value_gptr, result;

    // get 1
    key = 1;
    key_size = sizeof(key);
    memcpy((char*)&key_buf, (char*)&key, key_size);
    result = tree->get(key_buf, key_size);
    EXPECT_EQ(0UL, result);

    // destroy 1
    key = 1;
    key_size = sizeof(key);
    memcpy((char*)&key_buf, (char*)&key, key_size);
    result = tree->destroy(key_buf, key_size);
    EXPECT_EQ(0UL, result);

    // put 1:1
    key = 1;
    key_size = sizeof(key);
    memcpy((char*)&key_buf, (char*)&key, key_size);

    value = 1;
    value_gptr = heap->Alloc(sizeof(value));
    value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
    *value_ptr = value;
    pmem_persist(value_ptr, sizeof(value));

    success = tree->put(key_buf, key_size, value_gptr);
    EXPECT_EQ(true, success);

    // get 1
    key = 1;
    key_size = sizeof(key);
    memcpy((char*)&key_buf, (char*)&key, key_size);
    result = tree->get(key_buf, key_size);
    EXPECT_EQ(value_gptr, result);

    // destroy 1
    key = 1;
    key_size = sizeof(key);
    memcpy((char*)&key_buf, (char*)&key, key_size);
    result = tree->destroy(key_buf, key_size);
    EXPECT_EQ(value_gptr, result);
    heap->Free(result);

    // get 1
    key = 1;
    key_size = sizeof(key);
    memcpy((char*)&key_buf, (char*)&key, key_size);
    result = tree->get(key_buf, key_size);
    EXPECT_EQ(0UL, result);

    delete tree;

    EXPECT_EQ(NO_ERROR, heap->Close());
    EXPECT_EQ(NO_ERROR, mm->DestroyHeap(heap_id));
}

// multi-process
static int const process_count = 16;
static int const loop_count = 500;

void DoWork(GlobalPtr root, PoolId heap_id)
{
    // =======================================================================
    // init memory manager and heap
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = nullptr;
    EXPECT_EQ(NO_ERROR, mm->FindHeap(heap_id, &heap));
    EXPECT_NE(nullptr, heap);

    // open the heap
    EXPECT_EQ(NO_ERROR, heap->Open());

    // init the radix tree
    RadixTree *tree = nullptr;
    tree = new RadixTree(mm, heap, root);
    EXPECT_NE(nullptr, tree);

    // =======================================================================
    // stress test
    pid_t pid = getpid();

    RadixTree::key_type key_buf;
    memset(&key_buf, 0, sizeof(key_buf));
    std::string key;
    size_t key_size;
    std::string value;
    size_t value_size;
    uint64_t *value_ptr;
    GlobalPtr value_gptr, result;

    GlobalPtr ptr;
    for (int i=0; i<loop_count; i++)
    {
        key = rand_string(1, sizeof(key_buf)-1);
        key_size = key.size();
        memcpy((char*)&key_buf, key.c_str(), key_size+1);

        value = rand_string(0, sizeof(key_buf)-1);
        value_size = value.size();
        value_gptr = heap->Alloc(value_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
        memcpy((char*)value_ptr, value.c_str(), value_size+1);
        pmem_persist(value_ptr, value_size+1);

        int op=(i+pid)%3;
        if (op==0)
        {
            tree->put(key_buf, (int)key_size, value_gptr);
        }
        else if (op==1)
        {
            tree->get(key_buf, (int)key_size);
        }
        else
        {
            GlobalPtr result = tree->destroy(key_buf, (int)key_size);
            if (result!=0)
                heap->Free(result);
        }
    }
    std::cout << pid << " DONE" << std::endl;

    // =======================================================================
    // close the heap
    EXPECT_EQ(NO_ERROR, heap->Close());
    delete heap;
    delete tree;
}

TEST(RadixTree, MultiProcessStress) {
    PoolId const heap_id = 1; // assuming we only use heap id 1
    size_t const heap_size = 1024*1024*1024; // 1024MB

    // =======================================================================
    // init memory manager and heap
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = nullptr;
    EXPECT_EQ(NO_ERROR, mm->CreateHeap(heap_id, heap_size));
    EXPECT_EQ(NO_ERROR, mm->FindHeap(heap_id, &heap));
    EXPECT_NE(nullptr, heap);

    // open the heap
    EXPECT_EQ(NO_ERROR, heap->Open());

    // init the radix tree
    RadixTree *tree = nullptr;
    GlobalPtr root;
    // create a new radix tree
    tree = new RadixTree(mm, heap);
    root = tree->get_root();
    EXPECT_NE(nullptr, tree);
    delete tree;

    // close the heap
    EXPECT_EQ(NO_ERROR, heap->Close());

    // =======================================================================
    // do work
    pid_t pid[process_count];

    for (int i=0; i< process_count; i++)
    {
        pid[i] = fork();
        ASSERT_LE(0, pid[i]);
        if (pid[i]==0)
        {
            // child
            DoWork(root, heap_id);
            exit(0); // this will leak memory (see valgrind output)
        }
        else
        {
            // parent
            continue;
        }
    }

    for (int i=0; i< process_count; i++)
    {
        int status;
        waitpid(pid[i], &status, 0);
    }

    // =======================================================================
    // destroy the heap
    EXPECT_EQ(NO_ERROR, mm->DestroyHeap(heap_id));
    // tree = new RadixTree(mm, heap, root);
    // tree->list([&mm](const RadixTree::key_type &key, const int key_size, GlobalPtr p) {
    //         char *value = (char*)mm->GlobalToLocal(p);
    //         std::cout <<"  " << std::string((const char*)&key, sizeof(key))  << " -> " << std::string(value) << std::endl;
    //         });
    // delete tree;
}


void Init()
{
    // check if SHELF_BASE_DIR exists
    std::cout << "Init: Checking if lfs exists..." << std::endl;
    boost::filesystem::path shelf_base_path = boost::filesystem::path(SHELF_BASE_DIR);
    if (boost::filesystem::exists(shelf_base_path) == false)
    {
        std::cout << "Init: LFS does not exist " << SHELF_BASE_DIR << std::endl;
        exit(1);
    }

    // create a root shelf for MemoryManager if it does not exist
    std::cout << "Init: Creating the root shelf if it does not exist..." << std::endl;
    std::string root_shelf_file = std::string(SHELF_BASE_DIR) + "/" + SHELF_USER + "_NVMM_ROOT";
    RootShelf root_shelf(root_shelf_file);
    if(root_shelf.Exist() == false)
    {
        if(root_shelf.Create()!=NO_ERROR)
        {
            std::cout << "Init: Failed to create the root shelf file " << root_shelf_file << std::endl;
            exit(1);
        }
    }
}

int main (int argc, char** argv) {
    // remove previous files in SHELF_BASE_DIR
    std::string cmd = std::string("exec rm -f ") + SHELF_BASE_DIR + "/" + SHELF_USER + "* > /dev/null";
    system(cmd.c_str());

    Init();
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
