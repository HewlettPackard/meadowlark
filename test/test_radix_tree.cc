/*
 *  (c) Copyright 2016-2020 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <gtest/gtest.h>
#include <random>

#include "radixtree/radix_tree.h"

#include "nvmm/memory_manager.h"
#include "nvmm/epoch_manager.h"
#include "nvmm/heap.h"
#include "nvmm/fam.h"


using namespace radixtree;
using namespace nvmm;

// random number and string generator
std::random_device r;
std::default_random_engine e1(r());
uint64_t rand_uint64(uint64_t min, uint64_t max)
{
    std::uniform_int_distribution<uint64_t> uniform_dist(min, max);
    return uniform_dist(e1);
}

std::string rand_string(size_t min_len, size_t max_len)
{
    static char const dict[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

    size_t len = (size_t)rand_uint64(min_len, max_len);
    std::string ret(len, '\0');
    for (size_t i = 0; i < len; i++)
    {
        ret[i]=dict[rand_uint64(0,sizeof(dict)-2)];
    }

    return ret;
}

// endianness conversion for uint64_t
inline uint64_t convert(uint64_t num) {
#ifdef SYS_LITTLE_ENDIAN
    num = __builtin_bswap64(num);
#endif
    return num;
}


// single process: put, get, destroy
TEST(RadixTree, SingleProcess) {
    PoolId const heap_id = 1; // assuming we only use heap id 1
    size_t const heap_size = 1024*1024*1024; // 1024MB

    // init memory manager and heap
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = nullptr;
    EXPECT_EQ(NO_ERROR, mm->CreateHeap(heap_id, heap_size));
    EXPECT_EQ(NO_ERROR, mm->FindHeap(heap_id, &heap));
    EXPECT_NE(nullptr, heap);

    // open the heap
    EXPECT_EQ(NO_ERROR, heap->Open());

    // init the radix tree
    RadixTree *tree = nullptr;
    GlobalPtr root;
    // create a new radix tree
    tree = new RadixTree(mm, heap, NULL);
    root = tree->get_root();
    EXPECT_NE(nullptr, tree);
    delete tree;

    // open an existing radix tree
    tree = new RadixTree(mm, heap, NULL, root);
    EXPECT_NE(nullptr, tree);

    // test put, get, destroy
    char key_buf[RadixTree::MAX_KEY_LEN];
    size_t key_size;
    memset(key_buf, 0, sizeof(key_buf));
    uint64_t key, value;
    uint64_t *value_ptr;
    GlobalPtr value_gptr;
    TagGptr result, result_old;

    // get 1
    key = 1;
    key_size = sizeof(key);
    memcpy(key_buf, (char*)&key, key_size);
    result = tree->get(key_buf, key_size);
    EXPECT_EQ(0UL, result.gptr());

    // destroy 1
    key = 1;
    key_size = sizeof(key);
    memcpy(key_buf, (char*)&key, key_size);
    result = tree->destroy(key_buf, key_size);
    EXPECT_EQ(0UL, result.gptr());

    // put 1:1
    key = 1;
    key_size = sizeof(key);
    memcpy(key_buf, (char*)&key, key_size);

    value = 1;
    value_gptr = heap->Alloc(sizeof(value));
    value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
    *value_ptr = value;
    fam_persist(value_ptr, sizeof(value));

    result = tree->put(key_buf, key_size, value_gptr, UPDATE);
    EXPECT_EQ(0UL, result.gptr());

    // get 1
    key = 1;
    key_size = sizeof(key);
    memcpy(key_buf, (char*)&key, key_size);
    result = tree->get(key_buf, key_size);
    EXPECT_EQ(value_gptr, result.gptr());
    result_old = result;

    // put 1:2
    key = 1;
    key_size = sizeof(key);
    memcpy(key_buf, (char*)&key, key_size);

    value = 1;
    value_gptr = heap->Alloc(sizeof(value));
    value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
    *value_ptr = value;
    fam_persist(value_ptr, sizeof(value));

    result = tree->put(key_buf, key_size, value_gptr, UPDATE);
    EXPECT_EQ(result_old, result);
    heap->Free(result.gptr());

    // get 1
    key = 1;
    key_size = sizeof(key);
    memcpy(key_buf, (char*)&key, key_size);
    result = tree->get(key_buf, key_size);
    EXPECT_EQ(value_gptr, result.gptr());

    // destroy 1
    key = 1;
    key_size = sizeof(key);
    memcpy(key_buf, (char*)&key, key_size);
    result = tree->destroy(key_buf, key_size);
    EXPECT_EQ(value_gptr, result.gptr());
    heap->Free(result.gptr());

    // get 1
    key = 1;
    key_size = sizeof(key);
    memcpy(key_buf, (char*)&key, key_size);
    result = tree->get(key_buf, key_size);
    EXPECT_EQ(0UL, result.gptr());

    delete tree;

    EXPECT_EQ(NO_ERROR, heap->Close());
    EXPECT_EQ(NO_ERROR, mm->DestroyHeap(heap_id));
}


// single process: scan
TEST(RadixTree, SingleProcessScan) {
    PoolId const heap_id = 1; // assuming we only use heap id 1
    size_t const heap_size = 1024*1024*1024; // 1024MB

    // init memory manager and heap
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = nullptr;
    EXPECT_EQ(NO_ERROR, mm->CreateHeap(heap_id, heap_size));
    EXPECT_EQ(NO_ERROR, mm->FindHeap(heap_id, &heap));
    EXPECT_NE(nullptr, heap);

    // open the heap
    EXPECT_EQ(NO_ERROR, heap->Open());

    // init the radix tree
    RadixTree *tree = nullptr;
    GlobalPtr root;
    // create a new radix tree
    tree = new RadixTree(mm, heap, NULL);
    root = tree->get_root();
    EXPECT_NE(nullptr, tree);

    // insert
    char key_buf[RadixTree::MAX_KEY_LEN];
    size_t key_size;
    memset(key_buf, 0, sizeof(key_buf));
    uint64_t key, value;
    uint64_t *value_ptr;
    GlobalPtr value_gptr;
    TagGptr result;

    // insert '\0'
    key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
    memcpy(key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, key_size);
    value = '\0';
    value_gptr = heap->Alloc(sizeof(value));
    value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
    *value_ptr = value;
    fam_persist(value_ptr, sizeof(value));

    result = tree->put(key_buf, key_size, value_gptr, UPDATE);
    EXPECT_EQ(0UL, result.gptr());

    // insert [5,499]
    for(uint64_t i=5; i<500; i++) {
        key = convert(i);
        key_size = sizeof(key);
        memcpy(key_buf, (char*)&key, key_size);

        value = i;
        value_gptr = heap->Alloc(sizeof(value));
        value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
        *value_ptr = value;
        fam_persist(value_ptr, sizeof(value));

        result = tree->put(key_buf, key_size, value_gptr, UPDATE);
        EXPECT_EQ(0UL, result.gptr());
    }

    // scan
    int ret;
    char begin_key_buf[RadixTree::MAX_KEY_LEN], end_key_buf[RadixTree::MAX_KEY_LEN];
    memset(begin_key_buf, 0, sizeof(begin_key_buf));
    memset(end_key_buf, 0, sizeof(end_key_buf));
    uint64_t begin_key, end_key, begin_key_num, end_key_num;
    size_t begin_key_size, end_key_size;
    RadixTree::Iter iter;

    // 0 - 5
    begin_key_num = 0;
    end_key_num = 5;
    begin_key = convert(begin_key_num);
    end_key = convert(end_key_num);
    begin_key_size = sizeof(begin_key);
    end_key_size = sizeof(end_key);
    memcpy(begin_key_buf, (char*)&begin_key, begin_key_size);
    memcpy(end_key_buf, (char*)&end_key, end_key_size);

    // scan [0, 5]
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(0, ret);
        uint64_t i=end_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);

        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // scan (0, 5]
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(0, ret);
        uint64_t i=end_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);

        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // scan [0, 5)
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(-1, ret);
    }

    // scan (0, 5)
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(-1, ret);
    }

    // 499 - 600
    begin_key_num = 499;
    end_key_num = 600;
    begin_key = convert(begin_key_num);
    end_key = convert(end_key_num);
    begin_key_size = sizeof(begin_key);
    end_key_size = sizeof(end_key);
    memcpy(begin_key_buf, (char*)&begin_key, begin_key_size);
    memcpy(end_key_buf, (char*)&end_key, end_key_size);

    // scan [499, 600]
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);

        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // scan (499, 600]
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(-1, ret);
    }

    // scan [499, 600)
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);

        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // scan (499, 600)
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(-1, ret);
    }


    // 10 - 10
    begin_key_num = 10;
    end_key_num = 10;
    begin_key = convert(begin_key_num);
    end_key = convert(end_key_num);
    begin_key_size = sizeof(begin_key);
    end_key_size = sizeof(end_key);
    memcpy(begin_key_buf, (char*)&begin_key, begin_key_size);
    memcpy(end_key_buf, (char*)&end_key, end_key_size);

    // scan [10, 10]
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);

        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // scan (10, 10]
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(-1, ret);
    }

    // scan [10, 10)
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(-1, ret);
    }

    // scan (10, 10)
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(-1, ret);
    }

    // 10 - 100
    begin_key_num = 10;
    end_key_num = 100;
    begin_key = convert(begin_key_num);
    end_key = convert(end_key_num);
    begin_key_size = sizeof(begin_key);
    end_key_size = sizeof(end_key);
    memcpy(begin_key_buf, (char*)&begin_key, begin_key_size);
    memcpy(end_key_buf, (char*)&end_key, end_key_size);

    // scan [10, 100]
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);

        i++;
        for(; i<=end_key_num; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // scan [10, 100)
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);

        i++;
        for(; i<=end_key_num-1; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // scan (10, 100]
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num+1;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);

        i++;
        for(; i<=end_key_num; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // scan (10, 100)
    {
        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num+1;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);

        i++;
        for(; i<=end_key_num-1; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan [-inf, +inf] => not valid open boundaries  => scan ['\0','\0'] => '\0'
    {
        begin_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        end_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        memcpy(begin_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, begin_key_size);
        memcpy(end_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, end_key_size);

        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(0, ret);
        EXPECT_EQ((int)RadixTree::OPEN_BOUNDARY_KEY_SIZE, key_size);
        EXPECT_EQ(0, memcmp((char const *)RadixTree::OPEN_BOUNDARY_KEY, (char *)key_buf, key_size));
        EXPECT_EQ('\0', *((char*)mm->GlobalToLocal(result.gptr())));

        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan [-inf, +inf) => valid open boundary for end key => scan ['\0',+inf)
    {
        begin_key_num = 5;
        end_key_num = 499;
        begin_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        end_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        memcpy(begin_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, begin_key_size);
        memcpy(end_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, end_key_size);

        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(0, ret);
        EXPECT_EQ((int)RadixTree::OPEN_BOUNDARY_KEY_SIZE, key_size);
        EXPECT_EQ(0, memcmp((char const *)RadixTree::OPEN_BOUNDARY_KEY, (char *)key_buf, key_size));
        EXPECT_EQ('\0', *((char*)mm->GlobalToLocal(result.gptr())));

        uint64_t i=begin_key_num;
        for(; i<=end_key_num; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (-inf, +inf] => valid open boundary for begin key => scan (-inf, '\0']
    {
        begin_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        end_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        memcpy(begin_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, begin_key_size);
        memcpy(end_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, end_key_size);

        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(0, ret);
        EXPECT_EQ((int)RadixTree::OPEN_BOUNDARY_KEY_SIZE, key_size);
        EXPECT_EQ(0, memcmp((char const *)RadixTree::OPEN_BOUNDARY_KEY, (char *)key_buf, key_size));
        EXPECT_EQ('\0', *((char*)mm->GlobalToLocal(result.gptr())));

        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (-inf, +inf)
    {
        begin_key_num = 5;
        end_key_num = 499;
        begin_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        end_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        memcpy(begin_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, begin_key_size);
        memcpy(end_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, end_key_size);

        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);
        i++;

        for(; i<=end_key_num; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (-inf, 100]
    {
        begin_key_num = 5;
        end_key_num = 100;
        end_key = convert(end_key_num);
        begin_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        end_key_size = sizeof(end_key);
        memcpy(begin_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, begin_key_size);
        memcpy(end_key_buf, (char*)&end_key, end_key_size);

        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, true);
        EXPECT_EQ(0, ret);
        EXPECT_EQ((int)RadixTree::OPEN_BOUNDARY_KEY_SIZE, key_size);
        EXPECT_EQ(0, memcmp((char const *)RadixTree::OPEN_BOUNDARY_KEY, (char *)key_buf, key_size));
        EXPECT_EQ('\0', *((char*)mm->GlobalToLocal(result.gptr())));

        uint64_t i=begin_key_num;
        for(; i<=end_key_num; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan [10, +inf)
    {
        begin_key_num = 10;
        end_key_num = 499;
        begin_key = convert(begin_key_num);
        begin_key_size = sizeof(begin_key);
        end_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        memcpy(begin_key_buf, (char*)&begin_key, begin_key_size);
        memcpy(end_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, end_key_size);

        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, true,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);
        i++;

        for(; i<=end_key_num; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (-inf, 100)
    {
        begin_key_num = 5;
        end_key_num = 100;
        end_key = convert(end_key_num);
        begin_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        end_key_size = sizeof(end_key);
        memcpy(begin_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, begin_key_size);
        memcpy(end_key_buf, (char*)&end_key, end_key_size);

        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(0, ret);
        EXPECT_EQ((int)RadixTree::OPEN_BOUNDARY_KEY_SIZE, key_size);
        EXPECT_EQ(0, memcmp((char const *)RadixTree::OPEN_BOUNDARY_KEY, (char *)key_buf, key_size));
        EXPECT_EQ('\0', *((char*)mm->GlobalToLocal(result.gptr())));

        uint64_t i=begin_key_num;
        for(; i<=end_key_num-1; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // with open boundary
    // scan (10, +inf)
    {
        begin_key_num = 10;
        end_key_num = 499;
        begin_key = convert(begin_key_num);
        begin_key_size = sizeof(begin_key);
        end_key_size = RadixTree::OPEN_BOUNDARY_KEY_SIZE;
        memcpy(begin_key_buf, (char*)&begin_key, begin_key_size);
        memcpy(end_key_buf, (char const *)RadixTree::OPEN_BOUNDARY_KEY, end_key_size);

        ret = tree->scan(iter,
                         key_buf, key_size, result,
                         begin_key_buf, begin_key_size, false,
                         end_key_buf, end_key_size, false);
        EXPECT_EQ(0, ret);
        uint64_t i=begin_key_num+1;
        EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
        EXPECT_EQ((int)sizeof(i), key_size);
        value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
        EXPECT_EQ(i, *value_ptr);
        i++;

        for(; i<=end_key_num; i++) {
            ret = tree->get_next(iter, key_buf, key_size, result);
            EXPECT_EQ(0, ret);
            EXPECT_EQ(i, convert(*((uint64_t*)&key_buf)));
            EXPECT_EQ((int)sizeof(i), key_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr());
            EXPECT_EQ(i, *value_ptr);
        }
        ret = tree->get_next(iter, key_buf, key_size, result);
        EXPECT_EQ(-1, ret);
    }

    // done!
    delete tree;

    EXPECT_EQ(NO_ERROR, heap->Close());
    EXPECT_EQ(NO_ERROR, mm->DestroyHeap(heap_id));
}

// multi-process: put, get, destroy
static int const process_count = 16;
static int const loop_count = 5000;

void DoWork(GlobalPtr root, PoolId heap_id)
{
    // =======================================================================
    // reset epoch manager after fork()
    EpochManager *em = EpochManager::GetInstance();
    em->Start();

    // =======================================================================
    // init memory manager and heap
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = nullptr;
    EXPECT_EQ(NO_ERROR, mm->FindHeap(heap_id, &heap));
    EXPECT_NE(nullptr, heap);

    // open the heap
    EXPECT_EQ(NO_ERROR, heap->Open());

    // init the radix tree
    RadixTree *tree = nullptr;
    tree = new RadixTree(mm, heap, NULL, root);
    EXPECT_NE(nullptr, tree);

    // =======================================================================
    // stress test
    pid_t pid = getpid();

    char key_buf[RadixTree::MAX_KEY_LEN],begin_key_buf[RadixTree::MAX_KEY_LEN],end_key_buf[RadixTree::MAX_KEY_LEN];
    memset(key_buf, 0, sizeof(key_buf));
    memset(begin_key_buf, 0, sizeof(begin_key_buf));
    memset(end_key_buf, 0, sizeof(end_key_buf));
    std::string key, begin_key, end_key;
    size_t key_size, begin_key_size, end_key_size;
    std::string value;
    size_t value_size;
    uint64_t *value_ptr;
    GlobalPtr value_gptr;
    TagGptr result;

    GlobalPtr ptr;
    for (int i=0; i<loop_count; i++)
    {
        int op=(int)rand_uint64(0,3);
        if (op==0)
        {
            key = rand_string(1, sizeof(key_buf)-1);
            key_size =(int) key.size();
            memcpy(key_buf, key.c_str(), key_size+1);

            value = rand_string(0, sizeof(key_buf)-1);
            value_size = value.size();
            value_gptr = heap->Alloc(value_size);
            value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
            memcpy((char*)value_ptr, value.c_str(), value_size+1);
            fam_persist(value_ptr, value_size+1);

            result = tree->put(key_buf, key_size, value_gptr, UPDATE);
            if (result.gptr())
                heap->Free(result.gptr());
        }
        else if (op==1)
        {
            key = rand_string(1, sizeof(key_buf)-1);
            key_size =(int) key.size();
            memcpy(key_buf, key.c_str(), key_size+1);

            (void)tree->get(key_buf, key_size);
        }
        else if (op==2)
        {
            key = rand_string(1, sizeof(key_buf)-1);
            key_size = (int)key.size();
            memcpy(key_buf, key.c_str(), key_size+1);

            result = tree->destroy(key_buf, key_size);
            if (result.gptr())
                heap->Free(result.gptr());
        }
        else
        {
            begin_key = rand_string(1, sizeof(begin_key_buf)-1);
            begin_key_size = (int)begin_key.size();
            memcpy(begin_key_buf, begin_key.c_str(), begin_key_size+1);

            end_key = rand_string(1, sizeof(end_key_buf)-1);
            end_key_size = (int)end_key.size();
            memcpy(end_key_buf, end_key.c_str(), end_key_size+1);

            RadixTree::Iter iter;
            int ret = tree->scan(iter,
                                 key_buf, key_size, result,
                                 begin_key_buf, begin_key_size, true,
                                 end_key_buf, end_key_size, true);
            int cnt = (int)rand_uint64(0,100);
            for(int i=0; ret==0 && i<cnt; i++) {
                ret = tree->get_next(iter, key_buf, key_size, result);
            }
        }
    }
    std::cout << pid << " DONE" << std::endl;

    // =======================================================================
    // close the heap
    EXPECT_EQ(NO_ERROR, heap->Close());
    delete heap;
    delete tree;
}

TEST(RadixTree, MultiProcessStress) {
    PoolId const heap_id = 1; // assuming we only use heap id 1
    size_t const heap_size = 1024*1024*1024; // 1024MB

    // =======================================================================
    // init memory manager and heap
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = nullptr;
    EXPECT_EQ(NO_ERROR, mm->CreateHeap(heap_id, heap_size));
    EXPECT_EQ(NO_ERROR, mm->FindHeap(heap_id, &heap));
    EXPECT_NE(nullptr, heap);

    // open the heap
    EXPECT_EQ(NO_ERROR, heap->Open());

    // init the radix tree
    RadixTree *tree = nullptr;
    GlobalPtr root;
    // create a new radix tree
    tree = new RadixTree(mm, heap, NULL);
    root = tree->get_root();
    EXPECT_NE(nullptr, tree);
    delete tree;

    // close the heap before reset epoch manager
    EXPECT_EQ(NO_ERROR, heap->Close());

    // =======================================================================
    // reset epoch manager before fork()
    EpochManager *em = EpochManager::GetInstance();
    em->Stop();

    // =======================================================================
    // do work
    pid_t pid[process_count];

    for (int i=0; i< process_count; i++)
    {
        pid[i] = fork();
        ASSERT_LE(0, pid[i]);
        if (pid[i]==0)
        {
            // child
            DoWork(root, heap_id);
            exit(0); // this will leak memory (see valgrind output)
        }
        else
        {
            // parent
            continue;
        }
    }

    for (int i=0; i< process_count; i++)
    {
        int status;
        waitpid(pid[i], &status, 0);
    }

    // =======================================================================
    // destroy the heap
    EXPECT_EQ(NO_ERROR, mm->DestroyHeap(heap_id));
    // tree = new RadixTree(mm, heap, root);
    // tree->list([&mm](const key_type &key, const size_t key_size, GlobalPtr p) {
    //         char *value = (char*)mm->GlobalToLocal(p);
    //         std::cout <<"  " << std::string((const char*)&key, sizeof(key))  << " -> " << std::string(value) << std::endl;
    //         });
    // delete tree;

    // =======================================================================
    // reset epoch manager after fork() for the main process
    em->Start();
}

void Init()
{
    nvmm::ResetNVMM();
    nvmm::StartNVMM();
}

int main (int argc, char** argv) {
    Init();
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
