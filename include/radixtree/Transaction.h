/*
 *  (c) Copyright 2016-2017 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef TRANSACTION_H
#define TRANSACTION_H

#include <iostream>
#include <unordered_map>
#include <utility>
#include <assert.h>

#include "radixtree/radixtree_libpmem.h"
#include "radixtree/radixtree_fam_atomic.h"
#include "radixtree/RadixTree.h"
#include "radixtree/TransactionManager.h"
#include "radixtree/status.h"
#include "radixtree/log.h"

#include "nvmm/memory_manager.h"
#include "nvmm/heap.h"

namespace radixtree
{
class Transaction {
public:
    typedef RadixTree::Iter Iter;

    // Transaction ID
    typedef uint64_t tid_t;

    // Size of key or value if variable length
    static const int VARIABLE_LEN = -1;

    // Operation which does not require a txn ID
    //static const tid_t NO_TXN = -1;

    // Special character to indicate open boundary
    static const std::string OPEN_BOUNDARY;
    
    // Index handle    
    typedef struct 
    {
	bool valid;
	tid_t tid;
	uint64_t id;
	std::string indexName;
	Iter iter;
    } indexHandle;

    // Index access type    
    enum idxAccessType 
    {
        INDEX_READ_ONLY,
        INDEX_READ_WRITE    
    };


public:
    Transaction();

    Status startTxn (tid_t &tid /* returned */);

    Status commitTxn (bool &committed, /* returned */
			   const tid_t &tid);
                                     
    Status abortTxn (const tid_t &tid);
        
    Status createIndex (const tid_t &tid,
			     const std::string &indexName,
			     const bool unique = true,
			     const bool ordered = true, /* optional */
			     const bool ascending = true, /* optional */
			     const int keyLen = VARIABLE_LEN, /* -1 denotes variable length */
			     const int valueLen = VARIABLE_LEN /* -1 denotes variable length */);
                                 
    Status dropIndex (const tid_t &tid,
			   const std::string &indexName);

                                
    Status openIndex (indexHandle &ih, /* returned */
			   const tid_t &tid,
			   const std::string &indexName,
			   const idxAccessType &access /* RO vs. RW */);
                                
    Status closeIndex (indexHandle &ih,
			    const tid_t &tid);
                                
    Status insertIndexItem (indexHandle &ih,
				 const tid_t &tid,
				 const char *key,
				 const int keyLen,
				 const char *value,
				 const int valueLen);

    Status deleteIndexItem (indexHandle &ih,
				 const tid_t &tid,
				 const char *key, 
				 const int keyLen,
				 const char *val = NULL, 
				 const int valLen = 0);
                                      
    Status updateIndexItem (indexHandle &ih,
				 const tid_t &tid,
				 const char *key,
				 const int keyLen,
				 const char *value,
				 const int valueLen); /* assume this is only for value updates , not key updates */

    Status scanIndexItem (char *keyBuf, /* returned */
			       int &keyBufLen, /* returned */
			       char *valueBuf, /* returned */
			       int &valueBufLen, /* returned */
			       indexHandle &ih,
			       const tid_t &tid ,
			       const char *beginKey,
			       const int beginKeyLen,
			       const bool & beginInclusive,
			       const char *endKey,
			       const int endKeyLen,
			       const bool & endInclusive); /* can be used for point , range or full scans . Need to define MIN_VAL and MAX_VAL for open ranges . */

    Status nextIndexItem (char *keyBuf, /* returned */
			       int &keyBufLen, /* returned */
			       char *valueBuf, /* returned */
			       int &valueBufLen, /*returned */
			       indexHandle &ih ,
			       const tid_t &tid);
    
private:
    TransactionManager *tmgr;
};
    
}

#endif
